/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => WorkflowyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian6 = require("obsidian");

// src/constants.ts
var WORKFLOWY_VIEW_TYPE = "workflowy-view";
var WORKFLOWY_SHORTCUTS = {
  // 基础操作
  "Enter": "createNewBlock",
  //'Shift+Enter': 'insertLineBreak',  // 在节点内换行
  "Backspace": "handleBackspace",
  "Delete": "handleDelete",
  "Ctrl+Shift+Backspace": "clearBlockContent",
  // 清空当前节点内容
  "Ctrl+Enter": "toggleTodo",
  // 切换待办状态
  // 缩进操作
  "Tab": "indentBlock",
  "Shift+Tab": "outdentBlock",
  // 移动操作
  "Ctrl+Shift+ArrowUp": "moveBlockUp",
  "Ctrl+Shift+ArrowDown": "moveBlockDown",
  // 折叠操作
  "Alt+Enter": "toggleCollapse",
  // 导航操作
  "ArrowUp": "navigateUp",
  "ArrowDown": "navigateDown",
  // 'ArrowLeft': 'navigateLeft',    // 移除：让 ←/→ 保持默认的光标移动行为
  // 'ArrowRight': 'navigateRight',  // 如需块级导航，可使用 Alt+← 和 Alt+→
  // Zoom 导航
  "Alt+ArrowUp": "zoomOut",
  // 往上一层级 zoom（退出当前 zoom）
  "Alt+ArrowDown": "zoomIn",
  // 往下一层级 zoom（zoom 到当前聚焦的块）
  // 撤销重做
  "Ctrl+Z": "undo",
  "Ctrl+Y": "redo",
  "Ctrl+Shift+Z": "redo"
};
var UI_CONFIG = {
  indentSize: 30,
  bulletSize: 6,
  bulletColor: "#666666",
  hoverColor: "#3498db",
  focusBackground: "rgba(74, 144, 226, 0.1)",
  lineHeight: 1.6,
  fontSize: 14
};

// src/workflowy-view.ts
var import_obsidian4 = require("obsidian");

// src/utils.ts
function generateId() {
  return Math.random().toString(36).substr(2, 9);
}
function getKeyCombo(event) {
  const modifierKeys = ["Control", "Shift", "Alt", "Meta"];
  if (modifierKeys.includes(event.key)) {
    return "";
  }
  const parts = [];
  if (event.ctrlKey || event.metaKey)
    parts.push("Ctrl");
  if (event.altKey)
    parts.push("Alt");
  if (event.shiftKey)
    parts.push("Shift");
  const codeToKey = {
    "ArrowUp": "ArrowUp",
    "ArrowDown": "ArrowDown",
    "ArrowLeft": "ArrowLeft",
    "ArrowRight": "ArrowRight",
    "Enter": "Enter",
    "NumpadEnter": "Enter",
    "Tab": "Tab",
    "Backspace": "Backspace",
    "Delete": "Delete"
  };
  const specialKeys = {
    "ArrowUp": "ArrowUp",
    "ArrowDown": "ArrowDown",
    "ArrowLeft": "ArrowLeft",
    "ArrowRight": "ArrowRight",
    "Enter": "Enter",
    "Tab": "Tab",
    "Backspace": "Backspace",
    "Delete": "Delete"
  };
  let key;
  if (codeToKey[event.code]) {
    key = codeToKey[event.code];
  } else if (specialKeys[event.key]) {
    key = specialKeys[event.key];
  } else {
    key = event.key.toUpperCase();
  }
  parts.push(key);
  return parts.join("+");
}
function findBlockById(blocks, id) {
  for (const block of blocks) {
    if (block.id === id)
      return block;
    const found = findBlockById(block.children, id);
    if (found)
      return found;
  }
  return null;
}
function findParentBlock(blocks, childId) {
  for (const block of blocks) {
    if (block.children.some((child) => child.id === childId)) {
      return block;
    }
    const found = findParentBlock(block.children, childId);
    if (found)
      return found;
  }
  return null;
}
function getAllBlocks(blocks) {
  const result = [];
  function traverse(blockList) {
    for (const block of blockList) {
      result.push(block);
      traverse(block.children);
    }
  }
  traverse(blocks);
  return result;
}

// src/outline-parser.ts
var OutlineParser = class {
  /**
   * 将 Markdown 文本解析为大纲块结构
   * 支持所有 Markdown 元素类型
   * 
   * 策略：
   * 1. 列表项：逐行解析，构建层级结构（WorkFlowy 风格）
   * 2. 其他内容：合并连续的非列表行为一个块，交给 Obsidian 渲染器处理
   */
  parseMarkdown(content) {
    const lines = content.split("\n");
    const flatBlocks = [];
    let totalBlocks = 0;
    let maxLevel = 0;
    let nonListLines = [];
    const flushNonListBlock = () => {
      if (nonListLines.length > 0) {
        const blockContent = nonListLines.join("\n").trim();
        if (blockContent) {
          flatBlocks.push({
            id: generateId(),
            type: "paragraph",
            // 统一作为段落，让 Obsidian 渲染器处理
            content: blockContent,
            level: 0,
            collapsed: false,
            children: [],
            editable: true,
            useObsidianRenderer: true
          });
          totalBlocks++;
        }
        nonListLines = [];
      }
    };
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const trimmed = line.trim();
      const listMatch = line.match(/^(\s*)([-*+]|\d+\.)\s+(.*)$/);
      if (listMatch) {
        flushNonListBlock();
        const [, indent, , text] = listMatch;
        const tabCount = (indent.match(/\t/g) || []).length;
        const spaceCount = (indent.match(/ /g) || []).length;
        const level = tabCount > 0 ? tabCount : Math.floor(spaceCount / 2);
        maxLevel = Math.max(maxLevel, level);
        let isTodo = false;
        let todoCompleted = false;
        let content2 = text;
        const todoMatch = text.match(/^\[([ xX])\]\s+(.*)$/);
        if (todoMatch) {
          isTodo = true;
          todoCompleted = todoMatch[1].toLowerCase() === "x";
          content2 = todoMatch[2];
        }
        let j = i + 1;
        while (j < lines.length) {
          const nextLine = lines[j];
          const nextTrimmed = nextLine.trim();
          if (!nextTrimmed) {
            j++;
            continue;
          }
          const continuationMatch = nextLine.match(/^(\s+)([^-*+\d].*)$/);
          if (continuationMatch) {
            const [, nextIndent, continuationText] = continuationMatch;
            const nextIndentLength = nextIndent.length;
            const currentIndentLength = indent.length;
            if (nextIndentLength > currentIndentLength) {
              content2 += "\n" + continuationText.trim();
              j++;
            } else {
              break;
            }
          } else {
            break;
          }
        }
        i = j - 1;
        flatBlocks.push({
          id: generateId(),
          type: "list",
          content: content2,
          level,
          collapsed: false,
          children: [],
          isTodo,
          todoCompleted,
          editable: true,
          useObsidianRenderer: false
          // 列表项使用 WorkFlowy 风格渲染
        });
        totalBlocks++;
        continue;
      }
      nonListLines.push(line);
    }
    flushNonListBlock();
    const blocks = this.buildHierarchy(flatBlocks);
    return {
      blocks,
      metadata: {
        totalBlocks,
        maxLevel
      }
    };
  }
  /**
   * 构建列表项的层级关系
   * 非列表项作为顶级块，列表项按缩进构建树形结构
   */
  buildHierarchy(flatBlocks) {
    const result = [];
    const stack = [];
    for (const block of flatBlocks) {
      if (block.type !== "list") {
        result.push(block);
        stack.length = 0;
        continue;
      }
      while (stack.length > 0 && stack[stack.length - 1].level >= block.level) {
        stack.pop();
      }
      if (stack.length === 0) {
        result.push(block);
      } else {
        const parent = stack[stack.length - 1];
        parent.children.push(block);
        block.parent = parent;
      }
      stack.push(block);
    }
    return result;
  }
  /**
   * 将大纲块结构转换为 Markdown 文本
   * 支持所有块类型
   */
  blocksToMarkdown(blocks) {
    const lines = [];
    function processBlock(block, parentLevel = 0) {
      switch (block.type) {
        case "heading":
          const hashes = "#".repeat(block.headingLevel || 1);
          lines.push(`${hashes} ${block.content}`);
          break;
        case "code":
          lines.push("```" + (block.codeLanguage || ""));
          lines.push(block.content);
          lines.push("```");
          break;
        case "quote":
          const quotes = ">".repeat(block.quoteLevel || 1);
          lines.push(`${quotes} ${block.content}`);
          break;
        case "horizontal":
          lines.push("---");
          break;
        case "paragraph":
          lines.push(block.content);
          break;
        case "blank":
          lines.push("");
          break;
        case "list":
          const indent = "	".repeat(block.level);
          let content = block.content;
          if (block.isTodo) {
            const checkbox = block.todoCompleted ? "[x]" : "[ ]";
            content = `${checkbox} ${content}`;
          }
          if (content.includes("\n")) {
            const contentLines = content.split("\n");
            const firstLine = `${indent}- ${contentLines[0]}`;
            const continuationLines = contentLines.slice(1).map(
              (line) => `${indent}  ${line}`
            );
            lines.push(firstLine);
            lines.push(...continuationLines);
          } else {
            lines.push(`${indent}- ${content}`);
          }
          for (const child of block.children) {
            processBlock(child, block.level);
          }
          break;
      }
      if (block.type !== "list") {
        for (const child of block.children) {
          processBlock(child, parentLevel);
        }
      }
    }
    for (const block of blocks) {
      processBlock(block);
    }
    return lines.join("\n");
  }
  /**
   * 更新单个块的内容
   */
  updateBlockContent(blocks, blockId, newContent) {
    function updateInBlocks(blockList) {
      return blockList.map((block) => {
        if (block.id === blockId) {
          return { ...block, content: newContent };
        }
        return {
          ...block,
          children: updateInBlocks(block.children)
        };
      });
    }
    return updateInBlocks(blocks);
  }
  /**
   * 插入新块
   */
  insertBlock(blocks, newBlock, afterBlockId) {
    if (!afterBlockId) {
      return [...blocks, newBlock];
    }
    function insertInBlocks(blockList) {
      const result = [];
      for (const block of blockList) {
        result.push({
          ...block,
          children: insertInBlocks(block.children)
        });
        if (block.id === afterBlockId) {
          result.push(newBlock);
        }
      }
      return result;
    }
    return insertInBlocks(blocks);
  }
  /**
   * 删除块
   */
  deleteBlock(blocks, blockId) {
    function deleteFromBlocks(blockList) {
      return blockList.filter((block) => block.id !== blockId).map((block) => ({
        ...block,
        children: deleteFromBlocks(block.children)
      }));
    }
    return deleteFromBlocks(blocks);
  }
};

// src/block-editor.ts
var BlockEditor = class {
  constructor() {
    this.undoStack = [];
    this.redoStack = [];
    this.state = {
      blocks: [],
      focusedBlockId: null,
      collapsedBlocks: /* @__PURE__ */ new Set(),
      selectedBlocks: /* @__PURE__ */ new Set()
    };
    this.parser = new OutlineParser();
  }
  // 状态管理
  getState() {
    return { ...this.state };
  }
  setState(newState, saveHistory = true) {
    if (saveHistory) {
      this.saveToUndoStack();
    }
    this.state = { ...this.state, ...newState };
  }
  /**
   * 深拷贝状态（避免引用问题）
   * 使用自定义深拷贝避免循环引用问题（如parent属性）
   */
  cloneState(state) {
    return {
      blocks: this.deepCloneBlocks(state.blocks),
      focusedBlockId: state.focusedBlockId,
      collapsedBlocks: new Set(state.collapsedBlocks),
      selectedBlocks: new Set(state.selectedBlocks)
    };
  }
  /**
   * 深拷贝blocks数组（跳过循环引用属性如parent）
   */
  deepCloneBlocks(blocks) {
    return blocks.map((block) => ({
      id: block.id,
      type: block.type || "list",
      // 默认为列表类型
      content: block.content,
      level: block.level,
      collapsed: block.collapsed,
      isTodo: block.isTodo,
      todoCompleted: block.todoCompleted,
      children: this.deepCloneBlocks(block.children),
      // 新增的属性
      headingLevel: block.headingLevel,
      codeLanguage: block.codeLanguage,
      quoteLevel: block.quoteLevel,
      editable: block.editable,
      useObsidianRenderer: block.useObsidianRenderer
      // 注意：不复制parent等可能导致循环引用的属性
    }));
  }
  // 撤销/重做
  saveToUndoStack() {
    this.undoStack.push(this.cloneState(this.state));
    if (this.undoStack.length > 50) {
      this.undoStack.shift();
    }
    this.redoStack = [];
  }
  undo() {
    if (this.undoStack.length === 0) {
      return false;
    }
    this.redoStack.push(this.cloneState(this.state));
    const previousState = this.undoStack.pop();
    this.state = previousState;
    return true;
  }
  redo() {
    if (this.redoStack.length === 0) {
      return false;
    }
    this.undoStack.push(this.cloneState(this.state));
    const nextState = this.redoStack.pop();
    this.state = nextState;
    return true;
  }
  // 块操作
  createNewBlock(afterBlockId) {
    const newBlock = {
      id: generateId(),
      type: "list",
      // 新建块默认为列表项
      content: "",
      children: [],
      level: 0,
      collapsed: false
    };
    if (afterBlockId) {
      const afterBlock = findBlockById(this.state.blocks, afterBlockId);
      if (afterBlock) {
        newBlock.level = afterBlock.level;
      }
    }
    const newBlocks = this.parser.insertBlock(this.state.blocks, newBlock, afterBlockId);
    this.setState({
      blocks: newBlocks,
      focusedBlockId: newBlock.id
    });
    return newBlock;
  }
  createChildBlock(parentBlockId) {
    const parentBlock = findBlockById(this.state.blocks, parentBlockId);
    if (!parentBlock) {
      console.error("[BlockEditor] Parent block not found:", parentBlockId);
      return this.createNewBlock(parentBlockId);
    }
    const newBlock = {
      id: generateId(),
      type: "list",
      // 子块默认为列表项
      content: "",
      children: [],
      level: parentBlock.level + 1,
      collapsed: false
    };
    const newBlocks = this.addChildBlock(this.state.blocks, parentBlockId, newBlock);
    this.setState({
      blocks: newBlocks,
      focusedBlockId: newBlock.id
    });
    return newBlock;
  }
  addChildBlock(blocks, parentId, childBlock) {
    return blocks.map((block) => {
      if (block.id === parentId) {
        return {
          ...block,
          children: [...block.children, childBlock]
        };
      }
      return {
        ...block,
        children: this.addChildBlock(block.children, parentId, childBlock)
      };
    });
  }
  deleteBlock(blockId) {
    const block = findBlockById(this.state.blocks, blockId);
    if (!block)
      return false;
    const parent = findParentBlock(this.state.blocks, blockId);
    let newBlocks = this.parser.deleteBlock(this.state.blocks, blockId);
    if (block.children.length > 0 && parent) {
      for (const child of block.children) {
        child.level = block.level;
        newBlocks = this.parser.insertBlock(newBlocks, child, blockId);
      }
    }
    this.setState({ blocks: newBlocks });
    return true;
  }
  updateBlockContent(blockId, content) {
    const newBlocks = this.parser.updateBlockContent(this.state.blocks, blockId, content);
    this.setState({ blocks: newBlocks });
  }
  // 缩进操作
  indentBlock(blockId) {
    const block = findBlockById(this.state.blocks, blockId);
    if (!block)
      return false;
    const allBlocks = getAllBlocks(this.state.blocks);
    const currentIndex = allBlocks.findIndex((b) => b.id === blockId);
    if (currentIndex <= 0)
      return false;
    const prevBlock = allBlocks[currentIndex - 1];
    let newBlocks = this.parser.deleteBlock(this.state.blocks, blockId);
    const updatedBlock = { ...block, level: prevBlock.level + 1 };
    function addAsChild(blocks) {
      return blocks.map((b) => {
        if (b.id === prevBlock.id) {
          return { ...b, children: [...b.children, updatedBlock] };
        }
        return { ...b, children: addAsChild(b.children) };
      });
    }
    newBlocks = addAsChild(newBlocks);
    this.setState({ blocks: newBlocks });
    return true;
  }
  outdentBlock(blockId) {
    const block = findBlockById(this.state.blocks, blockId);
    const parent = findParentBlock(this.state.blocks, blockId);
    if (!block || !parent || block.level === 0)
      return false;
    let newBlocks = this.parser.deleteBlock(this.state.blocks, blockId);
    const updatedBlock = { ...block, level: parent.level };
    const grandParent = findParentBlock(this.state.blocks, parent.id);
    if (grandParent) {
      newBlocks = this.parser.insertBlock(newBlocks, updatedBlock, parent.id);
    } else {
      newBlocks.push(updatedBlock);
    }
    this.setState({ blocks: newBlocks });
    return true;
  }
  // 移动操作（在同一父级的兄弟节点间上/下移动）
  replaceChildren(blocks, parentId, newChildren) {
    return blocks.map((b) => {
      if (b.id === parentId) {
        return { ...b, children: newChildren };
      }
      if (b.children && b.children.length > 0) {
        return { ...b, children: this.replaceChildren(b.children, parentId, newChildren) };
      }
      return { ...b };
    });
  }
  getParentAndSiblings(blockId) {
    const parent = findParentBlock(this.state.blocks, blockId);
    const siblings = parent ? parent.children : this.state.blocks;
    const index = siblings.findIndex((b) => b.id === blockId);
    if (index === -1)
      return null;
    return { parent: parent || null, siblings, index };
  }
  moveBlockUp(blockId) {
    const info = this.getParentAndSiblings(blockId);
    if (!info)
      return false;
    const { parent, siblings, index } = info;
    if (index <= 0)
      return false;
    const newSiblings = siblings.slice();
    const tmp = newSiblings[index - 1];
    newSiblings[index - 1] = newSiblings[index];
    newSiblings[index] = tmp;
    let newBlocks;
    if (parent) {
      newBlocks = this.replaceChildren(this.state.blocks, parent.id, newSiblings);
    } else {
      newBlocks = newSiblings;
    }
    this.setState({ blocks: newBlocks });
    return true;
  }
  moveBlockDown(blockId) {
    const info = this.getParentAndSiblings(blockId);
    if (!info)
      return false;
    const { parent, siblings, index } = info;
    if (index >= siblings.length - 1)
      return false;
    const newSiblings = siblings.slice();
    const tmp = newSiblings[index + 1];
    newSiblings[index + 1] = newSiblings[index];
    newSiblings[index] = tmp;
    let newBlocks;
    if (parent) {
      newBlocks = this.replaceChildren(this.state.blocks, parent.id, newSiblings);
    } else {
      newBlocks = newSiblings;
    }
    this.setState({ blocks: newBlocks });
    return true;
  }
  // 折叠操作
  toggleCollapse(blockId) {
    const block = findBlockById(this.state.blocks, blockId);
    if (!block || block.children.length === 0)
      return false;
    const newCollapsed = new Set(this.state.collapsedBlocks);
    if (newCollapsed.has(blockId)) {
      newCollapsed.delete(blockId);
    } else {
      newCollapsed.add(blockId);
    }
    this.setState({ collapsedBlocks: newCollapsed }, false);
    return true;
  }
  isCollapsed(blockId) {
    return this.state.collapsedBlocks.has(blockId);
  }
  /**
   * 折叠指定块
   * 注意：与 toggleCollapse 不同，这里允许折叠没有子项的块
   * 这是为了与 obsidian-outliner 的行为保持一致
   */
  collapse(blockId) {
    const block = findBlockById(this.state.blocks, blockId);
    if (!block)
      return false;
    if (!this.state.collapsedBlocks.has(blockId)) {
      const newCollapsed = new Set(this.state.collapsedBlocks);
      newCollapsed.add(blockId);
      this.setState({ collapsedBlocks: newCollapsed }, false);
      return true;
    }
    return false;
  }
  /**
   * 展开指定块
   */
  expand(blockId) {
    if (this.state.collapsedBlocks.has(blockId)) {
      const newCollapsed = new Set(this.state.collapsedBlocks);
      newCollapsed.delete(blockId);
      this.setState({ collapsedBlocks: newCollapsed }, false);
      return true;
    }
    return false;
  }
  /**
   * 切换待办状态
   */
  toggleTodo(blockId) {
    const block = findBlockById(this.state.blocks, blockId);
    if (!block)
      return false;
    const updateTodoInBlocks = (blocks) => {
      return blocks.map((b) => {
        if (b.id === blockId) {
          if (b.isTodo) {
            return { ...b, todoCompleted: !b.todoCompleted };
          } else {
            return { ...b, isTodo: true, todoCompleted: false };
          }
        }
        return {
          ...b,
          children: updateTodoInBlocks(b.children)
        };
      });
    };
    const newBlocks = updateTodoInBlocks(this.state.blocks);
    this.setState({ blocks: newBlocks });
    return true;
  }
  // 焦点管理
  focusBlock(blockId) {
    this.setState({ focusedBlockId: blockId }, false);
  }
  getFocusedBlock() {
    if (!this.state.focusedBlockId)
      return null;
    return findBlockById(this.state.blocks, this.state.focusedBlockId);
  }
  // 导航
  navigateUp() {
    const focused = this.getFocusedBlock();
    if (!focused)
      return false;
    const allBlocks = getAllBlocks(this.state.blocks);
    const currentIndex = allBlocks.findIndex((b) => b.id === focused.id);
    if (currentIndex > 0) {
      this.focusBlock(allBlocks[currentIndex - 1].id);
      return true;
    }
    return false;
  }
  navigateDown() {
    const focused = this.getFocusedBlock();
    if (!focused)
      return false;
    const allBlocks = getAllBlocks(this.state.blocks);
    const currentIndex = allBlocks.findIndex((b) => b.id === focused.id);
    if (currentIndex < allBlocks.length - 1) {
      this.focusBlock(allBlocks[currentIndex + 1].id);
      return true;
    }
    return false;
  }
  navigateLeft() {
    const focused = this.getFocusedBlock();
    if (!focused)
      return false;
    const parent = findParentBlock(this.state.blocks, focused.id);
    if (parent) {
      this.focusBlock(parent.id);
      return true;
    }
    return false;
  }
  navigateRight() {
    const focused = this.getFocusedBlock();
    if (!focused)
      return false;
    if (focused.children.length > 0) {
      this.focusBlock(focused.children[0].id);
      return true;
    }
    return false;
  }
  // 导出为 Markdown
  toMarkdown() {
    const markdown = this.parser.blocksToMarkdown(this.state.blocks);
    return markdown;
  }
  // 从 Markdown 加载
  loadFromMarkdown(content) {
    const result = this.parser.parseMarkdown(content);
    this.setState({
      blocks: result.blocks,
      focusedBlockId: null,
      collapsedBlocks: /* @__PURE__ */ new Set(),
      selectedBlocks: /* @__PURE__ */ new Set()
    });
  }
  /**
   * 移动块到指定位置
   */
  moveBlock(sourceBlockId, targetBlockId, position) {
    var _a;
    const allBlocks = getAllBlocks(this.state.blocks);
    const sourceBlock = allBlocks.find((b) => b.id === sourceBlockId);
    const targetBlock = allBlocks.find((b) => b.id === targetBlockId);
    if (!sourceBlock || !targetBlock) {
      return false;
    }
    if (this.wouldCreateCycle(sourceBlockId, targetBlockId, position)) {
      return false;
    }
    const newBlocks = this.removeBlockFromTree(this.state.blocks, sourceBlockId);
    const newAllBlocks = getAllBlocks(newBlocks);
    const newTargetBlock = newAllBlocks.find((b) => b.id === targetBlockId);
    if (!newTargetBlock) {
      return false;
    }
    let targetLevel;
    let insertParentId = null;
    let insertIndex;
    if (position === "child") {
      insertParentId = targetBlockId;
      insertIndex = 0;
      targetLevel = newTargetBlock.level + 1;
    } else {
      insertParentId = this.findParentIdInBlocks(newBlocks, targetBlockId);
      targetLevel = newTargetBlock.level;
      const siblings = insertParentId ? ((_a = newAllBlocks.find((b) => b.id === insertParentId)) == null ? void 0 : _a.children) || [] : newBlocks;
      const targetIndex = siblings.findIndex((b) => b.id === targetBlockId);
      insertIndex = position === "before" ? targetIndex : targetIndex + 1;
    }
    const updatedSourceBlock = this.updateBlockLevel(sourceBlock, targetLevel);
    const finalBlocks = this.insertBlockAtPosition(newBlocks, updatedSourceBlock, insertParentId, insertIndex);
    this.setState({ blocks: finalBlocks });
    return true;
  }
  /**
   * 检查移动是否会造成循环引用
   */
  wouldCreateCycle(sourceBlockId, targetBlockId, position) {
    if (position !== "child") {
      return false;
    }
    return this.isDescendant(sourceBlockId, targetBlockId);
  }
  /**
   * 检查是否是后代关系
   */
  isDescendant(ancestorId, descendantId) {
    const allBlocks = getAllBlocks(this.state.blocks);
    const ancestor = allBlocks.find((b) => b.id === ancestorId);
    if (!ancestor)
      return false;
    const checkChildren = (children) => {
      for (const child of children) {
        if (child.id === descendantId) {
          return true;
        }
        if (checkChildren(child.children)) {
          return true;
        }
      }
      return false;
    };
    return checkChildren(ancestor.children);
  }
  /**
   * 从树中移除指定块
   */
  removeBlockFromTree(blocks, blockId) {
    return blocks.map((block) => {
      if (block.id === blockId) {
        return null;
      }
      return {
        ...block,
        children: this.removeBlockFromTree(block.children, blockId)
      };
    }).filter((block) => block !== null);
  }
  /**
   * 更新块及其所有子块的层级
   * 递归更新块及其所有子孙节点的 level，保持相对层级关系
   */
  updateBlockLevel(block, newLevel) {
    const levelDiff = newLevel - block.level;
    const updateLevel = (b) => ({
      ...b,
      level: b.level + levelDiff,
      children: b.children.map(updateLevel)
    });
    return updateLevel(block);
  }
  /**
   * 在指定位置插入块
   */
  insertBlockAtPosition(blocks, blockToInsert, parentId, index) {
    if (!parentId) {
      const newBlocks = [...blocks];
      newBlocks.splice(index, 0, blockToInsert);
      return newBlocks;
    }
    return blocks.map((block) => {
      if (block.id === parentId) {
        const newChildren = [...block.children];
        newChildren.splice(index, 0, blockToInsert);
        return { ...block, children: newChildren };
      }
      return {
        ...block,
        children: this.insertBlockAtPosition(block.children, blockToInsert, parentId, index)
      };
    });
  }
  /**
   * 查找父块ID
   */
  findParentId(blockId) {
    return this.findParentIdInBlocks(this.state.blocks, blockId);
  }
  /**
   * 在指定的块树中查找父块ID
   */
  findParentIdInBlocks(blocks, blockId) {
    const allBlocks = getAllBlocks(blocks);
    for (const block of allBlocks) {
      if (block.children.some((child) => child.id === blockId)) {
        return block.id;
      }
    }
    return null;
  }
};

// src/isolation-guard.ts
var IsolationGuard = class {
  /**
   * 检查当前是否在 Workflowy 视图中
   */
  static isInWorkflowyView(leaf) {
    if (!leaf)
      return false;
    return leaf.view.getViewType() === WORKFLOWY_VIEW_TYPE;
  }
  /**
   * 检查当前是否在标准 Markdown 视图中
   */
  static isInMarkdownView(leaf) {
    if (!leaf)
      return false;
    return leaf.view.getViewType() === "markdown";
  }
  /**
   * 安全执行 Workflowy 功能 - 只在 Workflowy 视图中执行
   */
  static safeExecuteWorkflowyAction(leaf, action) {
    if (this.isInWorkflowyView(leaf)) {
      action();
      return true;
    }
    return false;
  }
  /**
   * 检查是否应该显示 Workflowy 菜单项
   */
  static shouldShowWorkflowyMenuItem(leaf) {
    return this.isInMarkdownView(leaf);
  }
  /**
   * 检查是否应该显示 Markdown 菜单项
   */
  static shouldShowMarkdownMenuItem(leaf) {
    return this.isInWorkflowyView(leaf);
  }
  /**
   * 确保样式只应用于 Workflowy 容器
   */
  static createIsolatedStyleSelector(selector) {
    if (selector.startsWith(".workflowy-container")) {
      return selector;
    }
    return `.workflowy-container ${selector}`;
  }
  /**
   * 验证元素是否在 Workflowy 容器内
   */
  static isElementInWorkflowyContainer(element) {
    return element.closest(".workflowy-container") !== null;
  }
  /**
   * 阻止事件冒泡到非 Workflowy 区域
   */
  static preventEventLeakage(event) {
    const target = event.target;
    if (!this.isElementInWorkflowyContainer(target)) {
      event.stopPropagation();
      event.preventDefault();
    }
  }
};

// src/ui/obsidian-block-renderer.ts
var import_obsidian = require("obsidian");
var ObsidianBlockRenderer = class extends import_obsidian.Component {
  constructor(app, block, containerEl, sourcePath, onContentChange) {
    super();
    this.contentEl = null;
    this.app = app;
    this.block = block;
    this.containerEl = containerEl;
    this.sourcePath = sourcePath;
    this.onContentChange = onContentChange;
  }
  /**
   * 渲染块内容
   */
  async render() {
    this.containerEl.empty();
    this.containerEl.addClass("obsidian-block-renderer");
    this.containerEl.setAttribute("data-block-type", this.block.type);
    this.containerEl.setAttribute("data-block-id", this.block.id);
    switch (this.block.type) {
      case "heading":
        await this.renderHeading();
        break;
      case "code":
        await this.renderCode();
        break;
      case "paragraph":
        await this.renderParagraph();
        break;
      case "quote":
        await this.renderQuote();
        break;
      case "horizontal":
        this.renderHorizontalRule();
        break;
      default:
        console.warn(`\u672A\u77E5\u5757\u7C7B\u578B: ${this.block.type}`);
    }
  }
  /**
   * 渲染标题
   */
  async renderHeading() {
    const level = this.block.headingLevel || 1;
    const markdown = `${"#".repeat(level)} ${this.block.content}`;
    const wrapper = this.containerEl.createDiv({
      cls: `obsidian-heading obsidian-heading-${level}`
    });
    await import_obsidian.MarkdownRenderer.render(
      this.app,
      markdown,
      wrapper,
      this.sourcePath,
      this
    );
    wrapper.addClass("obsidian-readonly");
    wrapper.setAttribute("title", "\u8BF7\u5728 Markdown \u89C6\u56FE\u4E2D\u7F16\u8F91\u6807\u9898");
    const readonlyBadge = wrapper.createDiv({
      cls: "obsidian-readonly-badge",
      text: "\u53EA\u8BFB"
    });
    this.enableLinkClicks(wrapper);
  }
  /**
   * 渲染代码块
   */
  async renderCode() {
    const language = this.block.codeLanguage || "";
    const markdown = "```" + language + "\n" + this.block.content + "\n```";
    const wrapper = this.containerEl.createDiv({
      cls: "obsidian-code-block"
    });
    await import_obsidian.MarkdownRenderer.render(
      this.app,
      markdown,
      wrapper,
      this.sourcePath,
      this
    );
    wrapper.addClass("obsidian-readonly");
    wrapper.setAttribute("title", "\u8BF7\u5728 Markdown \u89C6\u56FE\u4E2D\u7F16\u8F91\u4EE3\u7801");
    const readonlyBadge = wrapper.createDiv({
      cls: "obsidian-readonly-badge",
      text: "\u53EA\u8BFB"
    });
  }
  /**
   * 渲染段落
   */
  async renderParagraph() {
    const wrapper = this.containerEl.createDiv({
      cls: "obsidian-paragraph"
    });
    await import_obsidian.MarkdownRenderer.render(
      this.app,
      this.block.content,
      wrapper,
      this.sourcePath,
      this
    );
    wrapper.addClass("obsidian-readonly");
    wrapper.setAttribute("title", "\u8BF7\u5728 Markdown \u89C6\u56FE\u4E2D\u7F16\u8F91\u6B64\u5185\u5BB9\u4EE5\u4FDD\u7559\u683C\u5F0F");
    const readonlyBadge = wrapper.createDiv({
      cls: "obsidian-readonly-badge",
      text: "\u53EA\u8BFB"
    });
    this.enableLinkClicks(wrapper);
  }
  /**
   * 启用 Obsidian 链接的点击功能
   */
  enableLinkClicks(container) {
    this.registerDomEvent(container, "click", async (e) => {
      var _a, _b;
      const target = e.target;
      const link = target.closest("a");
      if (!link)
        return;
      if (link.classList.contains("internal-link")) {
        e.preventDefault();
        e.stopPropagation();
        const href = link.getAttribute("data-href");
        if (href) {
          const file = this.app.metadataCache.getFirstLinkpathDest(href, this.sourcePath);
          if (file) {
            const leaf = this.app.workspace.activeLeaf;
            if (leaf) {
              const currentViewType = leaf.view.getViewType();
              await leaf.setViewState({
                type: currentViewType,
                // 保持当前视图类型
                state: {
                  file: file.path
                }
              });
            } else {
              this.app.workspace.openLinkText(href, this.sourcePath, false);
            }
          } else {
            this.app.workspace.openLinkText(href, this.sourcePath, false);
          }
        }
        return;
      }
      if (link.classList.contains("tag")) {
        e.preventDefault();
        e.stopPropagation();
        const tagName = link.getAttribute("href");
        if (tagName) {
          const searchPlugin = (_b = (_a = this.app.internalPlugins) == null ? void 0 : _a.getPluginById) == null ? void 0 : _b.call(_a, "global-search");
          if (searchPlugin == null ? void 0 : searchPlugin.instance) {
            searchPlugin.instance.openGlobalSearch(`tag:${tagName.replace("#", "")}`);
          }
        }
        return;
      }
      if (link.classList.contains("external-link")) {
        e.stopPropagation();
        return;
      }
    }, true);
  }
  /**
   * 渲染引用块
   */
  async renderQuote() {
    const level = this.block.quoteLevel || 1;
    const markdown = ">".repeat(level) + " " + this.block.content;
    const wrapper = this.containerEl.createDiv({
      cls: "obsidian-quote"
    });
    await import_obsidian.MarkdownRenderer.render(
      this.app,
      markdown,
      wrapper,
      this.sourcePath,
      this
    );
    wrapper.addClass("obsidian-readonly");
    wrapper.setAttribute("title", "\u8BF7\u5728 Markdown \u89C6\u56FE\u4E2D\u7F16\u8F91\u5F15\u7528");
    const readonlyBadge = wrapper.createDiv({
      cls: "obsidian-readonly-badge",
      text: "\u53EA\u8BFB"
    });
    this.enableLinkClicks(wrapper);
  }
  /**
   * 渲染分割线
   */
  renderHorizontalRule() {
    const hr = this.containerEl.createEl("hr", {
      cls: "obsidian-horizontal-rule"
    });
  }
  /**
   * 更新块内容
   */
  async updateContent(newContent) {
    this.block.content = newContent;
    await this.render();
  }
  /**
   * 清理资源
   */
  onunload() {
    if (this.contentEl) {
      this.contentEl.empty();
    }
  }
};

// src/ui/outline-item.ts
var import_obsidian3 = require("obsidian");

// src/features/live-preview-editor.ts
var import_obsidian2 = require("obsidian");
var LivePreviewEditor = class {
  constructor(app, element) {
    this.app = app;
    this.element = element;
  }
  /**
   * 绑定快捷键事件
   */
  bindShortcuts() {
    this.element.addEventListener("keydown", this.handleKeyDown.bind(this));
  }
  /**
   * 绑定右键菜单
   */
  bindContextMenu() {
    this.element.addEventListener("contextmenu", this.handleContextMenu.bind(this));
  }
  /**
   * 处理键盘快捷键
   */
  handleKeyDown(e) {
    const isMod = e.ctrlKey || e.metaKey;
    if (isMod && e.key === "b") {
      e.preventDefault();
      e.stopPropagation();
      this.toggleFormat("**", "**", "\u52A0\u7C97\u6587\u672C");
      return;
    }
    if (isMod && e.key === "i") {
      e.preventDefault();
      e.stopPropagation();
      this.toggleFormat("*", "*", "\u659C\u4F53\u6587\u672C");
      return;
    }
    if (isMod && e.key === "k") {
      e.preventDefault();
      e.stopPropagation();
      this.insertLink();
      return;
    }
    if (isMod && e.shiftKey && e.key === "H") {
      e.preventDefault();
      e.stopPropagation();
      this.toggleFormat("==", "==", "\u9AD8\u4EAE\u6587\u672C");
      return;
    }
  }
  /**
   * 处理右键菜单
   */
  handleContextMenu(e) {
    e.preventDefault();
    e.stopPropagation();
    const menu = new import_obsidian2.Menu();
    const selection = window.getSelection();
    const hasSelection = selection && selection.toString().length > 0;
    menu.addItem((item) => {
      item.setTitle("\u52A0\u7C97").setIcon("bold").onClick(() => this.toggleFormat("**", "**", "\u52A0\u7C97\u6587\u672C"));
    });
    menu.addItem((item) => {
      item.setTitle("\u659C\u4F53").setIcon("italic").onClick(() => this.toggleFormat("*", "*", "\u659C\u4F53\u6587\u672C"));
    });
    menu.addItem((item) => {
      item.setTitle("\u9AD8\u4EAE").setIcon("highlighter").onClick(() => this.toggleFormat("==", "==", "\u9AD8\u4EAE\u6587\u672C"));
    });
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle("\u63D2\u5165\u94FE\u63A5").setIcon("link").onClick(() => this.insertLink());
    });
    menu.addItem((item) => {
      item.setTitle("\u63D2\u5165\u5916\u90E8\u94FE\u63A5").setIcon("external-link").onClick(() => this.insertExternalLink());
    });
    menu.addSeparator();
    if (hasSelection) {
      menu.addItem((item) => {
        item.setTitle("\u526A\u5207").setIcon("scissors").onClick(() => {
          document.execCommand("cut");
        });
      });
      menu.addItem((item) => {
        item.setTitle("\u590D\u5236").setIcon("copy").onClick(() => {
          document.execCommand("copy");
        });
      });
    }
    menu.addItem((item) => {
      item.setTitle("\u7C98\u8D34").setIcon("clipboard").onClick(() => {
        document.execCommand("paste");
      });
    });
    menu.addItem((item) => {
      item.setTitle("\u4EE5\u7EAF\u6587\u672C\u5F62\u5F0F\u7C98\u8D34").setIcon("clipboard-paste").onClick(() => {
        navigator.clipboard.readText().then((text) => {
          this.insertText(text);
        });
      });
    });
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle("\u5168\u9009").setIcon("select-all").onClick(() => {
        const range = document.createRange();
        range.selectNodeContents(this.element);
        const sel = window.getSelection();
        if (sel) {
          sel.removeAllRanges();
          sel.addRange(range);
        }
      });
    });
    menu.showAtMouseEvent(e);
  }
  /**
   * 切换格式（加粗、斜体、高亮等）
   */
  toggleFormat(prefix, suffix, placeholder) {
    if (this.element instanceof HTMLTextAreaElement) {
      this.toggleFormatTextarea(prefix, suffix, placeholder);
      return;
    }
    const selection = window.getSelection();
    if (!selection || selection.rangeCount === 0)
      return;
    const range = selection.getRangeAt(0);
    const selectedText = selection.toString();
    if (selectedText) {
      const container = range.commonAncestorContainer;
      const textContent = container.textContent || "";
      const startOffset = range.startOffset;
      const endOffset = range.endOffset;
      const beforeText = textContent.substring(Math.max(0, startOffset - prefix.length), startOffset);
      const afterText = textContent.substring(endOffset, Math.min(textContent.length, endOffset + suffix.length));
      if (beforeText === prefix && afterText === suffix) {
        const newRange = document.createRange();
        newRange.setStart(container, startOffset - prefix.length);
        newRange.setEnd(container, endOffset + suffix.length);
        newRange.deleteContents();
        newRange.insertNode(document.createTextNode(selectedText));
      } else {
        range.deleteContents();
        range.insertNode(document.createTextNode(prefix + selectedText + suffix));
      }
    } else {
      range.insertNode(document.createTextNode(prefix + placeholder + suffix));
    }
    this.element.dispatchEvent(new Event("input", { bubbles: true }));
  }
  /**
   * 为 textarea 元素切换格式
   */
  toggleFormatTextarea(prefix, suffix, placeholder) {
    const textarea = this.element;
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const selectedText = textarea.value.substring(start, end);
    const beforeText = textarea.value.substring(0, start);
    const afterText = textarea.value.substring(end);
    let newText;
    let newCursorPos;
    if (selectedText) {
      const hasPrefixBefore = beforeText.endsWith(prefix);
      const hasSuffixAfter = afterText.startsWith(suffix);
      if (hasPrefixBefore && hasSuffixAfter) {
        newText = beforeText.slice(0, -prefix.length) + selectedText + afterText.slice(suffix.length);
        newCursorPos = start - prefix.length;
      } else {
        newText = beforeText + prefix + selectedText + suffix + afterText;
        newCursorPos = start + prefix.length + selectedText.length + suffix.length;
      }
    } else {
      newText = beforeText + prefix + placeholder + suffix + afterText;
      newCursorPos = start + prefix.length + placeholder.length + suffix.length;
    }
    textarea.value = newText;
    textarea.setSelectionRange(newCursorPos, newCursorPos);
    textarea.focus();
    textarea.dispatchEvent(new Event("input", { bubbles: true }));
  }
  /**
   * 插入内部链接
   */
  insertLink() {
    if (this.element instanceof HTMLTextAreaElement) {
      this.insertLinkTextarea();
      return;
    }
    const selection = window.getSelection();
    if (!selection || selection.rangeCount === 0)
      return;
    const range = selection.getRangeAt(0);
    const selectedText = selection.toString();
    const linkText = selectedText || "\u94FE\u63A5\u6587\u672C";
    const linkMarkdown = `[[${linkText}]]`;
    range.deleteContents();
    range.insertNode(document.createTextNode(linkMarkdown));
    this.element.dispatchEvent(new Event("input", { bubbles: true }));
  }
  /**
   * 为 textarea 插入内部链接
   */
  insertLinkTextarea() {
    const textarea = this.element;
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const selectedText = textarea.value.substring(start, end);
    const linkText = selectedText || "\u94FE\u63A5\u6587\u672C";
    const linkMarkdown = `[[${linkText}]]`;
    const beforeText = textarea.value.substring(0, start);
    const afterText = textarea.value.substring(end);
    textarea.value = beforeText + linkMarkdown + afterText;
    const newCursorPos = start + linkMarkdown.length;
    textarea.setSelectionRange(newCursorPos, newCursorPos);
    textarea.focus();
    textarea.dispatchEvent(new Event("input", { bubbles: true }));
  }
  /**
   * 插入外部链接
   */
  insertExternalLink() {
    if (this.element instanceof HTMLTextAreaElement) {
      this.insertExternalLinkTextarea();
      return;
    }
    const selection = window.getSelection();
    if (!selection || selection.rangeCount === 0)
      return;
    const range = selection.getRangeAt(0);
    const selectedText = selection.toString();
    const linkText = selectedText || "\u94FE\u63A5\u6587\u672C";
    const linkMarkdown = `[${linkText}](https://example.com)`;
    range.deleteContents();
    range.insertNode(document.createTextNode(linkMarkdown));
    this.element.dispatchEvent(new Event("input", { bubbles: true }));
  }
  /**
   * 为 textarea 插入外部链接
   */
  insertExternalLinkTextarea() {
    const textarea = this.element;
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const selectedText = textarea.value.substring(start, end);
    const linkText = selectedText || "\u94FE\u63A5\u6587\u672C";
    const linkMarkdown = `[${linkText}](https://example.com)`;
    const beforeText = textarea.value.substring(0, start);
    const afterText = textarea.value.substring(end);
    textarea.value = beforeText + linkMarkdown + afterText;
    const newCursorPos = start + linkMarkdown.length;
    textarea.setSelectionRange(newCursorPos, newCursorPos);
    textarea.focus();
    textarea.dispatchEvent(new Event("input", { bubbles: true }));
  }
  /**
   * 插入文本
   */
  insertText(text) {
    if (this.element instanceof HTMLTextAreaElement) {
      const textarea = this.element;
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      const beforeText = textarea.value.substring(0, start);
      const afterText = textarea.value.substring(end);
      textarea.value = beforeText + text + afterText;
      const newCursorPos = start + text.length;
      textarea.setSelectionRange(newCursorPos, newCursorPos);
      textarea.focus();
      textarea.dispatchEvent(new Event("input", { bubbles: true }));
      return;
    }
    const selection = window.getSelection();
    if (!selection || selection.rangeCount === 0)
      return;
    const range = selection.getRangeAt(0);
    range.deleteContents();
    range.insertNode(document.createTextNode(text));
    this.element.dispatchEvent(new Event("input", { bubbles: true }));
  }
  /**
   * 解绑事件
   */
  unbind() {
  }
};

// src/ui/outline-item.ts
var _OutlineItem = class {
  constructor(block, editor, onUpdate, onFocus, onRender, getMultiSelectionManager, onBulletClick, getZoomedBlockId, app, sourcePath, settings) {
    this.collapseIndicator = null;
    this.checkboxElement = null;
    // Obsidian 集成
    this.app = null;
    this.sourcePath = "";
    this.obsidianRenderer = null;
    this.renderPromise = null;
    // 双层渲染相关（Live Preview 模式）
    this.settings = null;
    this.isEditMode = false;
    this.displayElement = null;
    this.editorElement = null;
    this.contentWrapper = null;
    this.livePreviewEditor = null;
    this.isDragging = false;
    this.draggedBlock = null;
    var _a;
    this.block = block;
    this.editor = editor;
    this.onUpdate = onUpdate;
    this.onFocus = onFocus;
    this.onRender = onRender;
    this.getMultiSelectionManager = getMultiSelectionManager;
    this.onBulletClick = onBulletClick;
    this.getZoomedBlockId = getZoomedBlockId;
    this.app = app || null;
    this.sourcePath = sourcePath || "";
    this.settings = settings || null;
    this.ensureDropZoneElements();
    this.createElement();
    if ((this.block.type === "list" || !this.block.useObsidianRenderer) && ((_a = this.settings) == null ? void 0 : _a.editor.renderMode) !== "live-preview") {
      this.bindEvents();
    }
  }
  /**
   * 确保拖拽指示元素存在 - 复用 obsidian-outliner 的实现
   */
  ensureDropZoneElements() {
    if (!_OutlineItem.dropZone) {
      _OutlineItem.dropZone = document.createElement("div");
      _OutlineItem.dropZone.classList.add("workflowy-drop-zone");
      document.body.appendChild(_OutlineItem.dropZone);
      _OutlineItem.dropZonePadding = document.createElement("div");
      _OutlineItem.dropZonePadding.classList.add("workflowy-drop-zone-padding");
      _OutlineItem.dropZone.appendChild(_OutlineItem.dropZonePadding);
    }
  }
  /**
   * 创建元素结构（借鉴 OutlineItemSimple 的直接创建方式）
   * 支持混合渲染：列表项使用 WorkFlowy 风格，其他使用 Obsidian 渲染器
   */
  createElement() {
    var _a;
    this.element = document.createElement("div");
    this.element.className = "workflowy-item";
    this.element.setAttribute("data-block-id", this.block.id);
    this.element.setAttribute("data-block-type", this.block.type);
    this.element.setAttribute("data-level", this.block.level.toString());
    if (this.block.type !== "list" && this.block.useObsidianRenderer && this.app) {
      this.renderPromise = this.createObsidianRenderedElement().catch((err) => {
        console.error("[OutlineItem] Error creating Obsidian rendered element:", err);
      });
      return;
    }
    if (this.block.isTodo && this.block.todoCompleted) {
      this.element.classList.add("todo-completed");
    }
    this.element.style.paddingLeft = `${this.block.level * UI_CONFIG.indentSize}px`;
    const contentLine = document.createElement("div");
    contentLine.className = "workflowy-content-line";
    if (this.block.children.length > 0) {
      this.collapseIndicator = document.createElement("div");
      this.collapseIndicator.className = `workflowy-collapse ${this.editor.isCollapsed(this.block.id) ? "collapsed" : ""}`;
      this.collapseIndicator.innerHTML = this.editor.isCollapsed(this.block.id) ? "\u25B6" : "\u25BC";
      contentLine.appendChild(this.collapseIndicator);
    } else {
      const placeholder = document.createElement("div");
      placeholder.className = "workflowy-collapse-placeholder";
      contentLine.appendChild(placeholder);
    }
    this.bulletElement = document.createElement("div");
    this.bulletElement.className = "workflowy-bullet";
    this.bulletElement.draggable = true;
    this.bulletElement.title = "Drag to move, Click to zoom";
    contentLine.appendChild(this.bulletElement);
    if (this.block.isTodo) {
      this.checkboxElement = document.createElement("div");
      this.checkboxElement.className = "workflowy-checkbox";
      if (this.block.todoCompleted) {
        this.checkboxElement.classList.add("completed");
        this.checkboxElement.innerHTML = '<svg viewBox="0 0 16 16" width="12" height="12"><path d="M13.5 3L6 10.5L2.5 7" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>';
      } else {
        this.checkboxElement.innerHTML = "";
      }
      contentLine.appendChild(this.checkboxElement);
    }
    this.bulletElement.addEventListener("click", (e) => {
      if (!this.isDragging && this.onBulletClick) {
        e.preventDefault();
        e.stopPropagation();
        this.onBulletClick(this.block.id);
      }
    });
    if (((_a = this.settings) == null ? void 0 : _a.editor.renderMode) === "live-preview") {
      this.createLivePreviewContent(contentLine);
    } else {
      this.createSourceContent(contentLine);
    }
    this.element.appendChild(contentLine);
  }
  /**
   * 创建源码模式内容（保留原有实现）
   */
  createSourceContent(contentLine) {
    this.contentElement = document.createElement("div");
    this.contentElement.className = "workflowy-content";
    this.contentElement.contentEditable = "true";
    this.contentElement.textContent = this.block.content;
    this.contentElement.setAttribute("data-block-id", this.block.id);
    if (!this.block.content) {
      this.contentElement.setAttribute("data-placeholder", "\u8F93\u5165\u5185\u5BB9...");
    }
    contentLine.appendChild(this.contentElement);
  }
  /**
   * 创建 Live Preview 模式内容（双层渲染）
   */
  createLivePreviewContent(contentLine) {
    this.contentWrapper = document.createElement("div");
    this.contentWrapper.className = "workflowy-content-wrapper";
    this.displayElement = document.createElement("div");
    this.displayElement.className = "workflowy-content-display";
    this.contentWrapper.appendChild(this.displayElement);
    this.editorElement = document.createElement("textarea");
    this.editorElement.className = "workflowy-content-editor";
    this.editorElement.value = this.block.content;
    this.editorElement.style.display = "none";
    this.editorElement.setAttribute("data-block-id", this.block.id);
    this.editorElement.rows = 1;
    this.editorElement.style.overflow = "hidden";
    this.editorElement.style.resize = "none";
    this.contentWrapper.appendChild(this.editorElement);
    this.bindAutoResize();
    contentLine.appendChild(this.contentWrapper);
    this.bindLivePreviewEvents();
    this.renderDisplay();
    this.contentElement = this.editorElement;
  }
  /**
   * 绑定事件监听器（保留原有的错误处理）
   * 注意：此方法只应该在列表项上调用，非列表项使用 Obsidian 渲染器不需要这些事件
   */
  bindEvents() {
    if (!this.contentElement) {
      console.warn("[OutlineItem] bindEvents called but contentElement is undefined. Block type:", this.block.type);
      return;
    }
    if (this.collapseIndicator) {
      this.collapseIndicator.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.toggleCollapse();
      });
    }
    if (this.checkboxElement) {
      this.checkboxElement.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.handleCheckboxClick();
      });
    }
    this.contentElement.addEventListener("input", () => {
      this.handleContentChange();
    });
    this.contentElement.addEventListener("focus", () => {
      this.handleFocus();
    });
    this.contentElement.addEventListener("blur", () => {
      this.handleBlur();
    });
    this.element.addEventListener("mouseenter", () => {
      this.element.classList.add("hovered");
    });
    this.element.addEventListener("mouseleave", () => {
      this.element.classList.remove("hovered");
    });
    this.bulletElement.setAttribute("draggable", "true");
    this.bulletElement.addEventListener("dragstart", (e) => {
      this.handleDragStart(e);
    });
    this.element.addEventListener("dragover", (e) => this.handleDragOver(e), { capture: true });
    this.element.addEventListener("drop", (e) => this.handleDrop(e), { capture: true });
    this.element.addEventListener("dragend", (e) => this.handleDragEnd(e), { capture: true });
    this.element.addEventListener("dragleave", (e) => this.handleDragLeave(e), { capture: true });
  }
  /**
   * 键盘事件处理 - 使用 WORKFLOWY_SHORTCUTS 映射
   */
  handleKeyDown(e) {
    if (!IsolationGuard.isElementInWorkflowyContainer(e.target)) {
      return;
    }
    const searchInput = document.querySelector(".workflowy-search");
    if (searchInput && document.activeElement === searchInput) {
      return;
    }
    const keyCombo = getKeyCombo(e);
    if (keyCombo === "Tab" || keyCombo === "Shift+Tab") {
      e.preventDefault();
      e.stopPropagation();
    }
    const operation = WORKFLOWY_SHORTCUTS[keyCombo];
    if (operation) {
      const shouldPrevent = this.shouldPreventDefault(operation, e);
      if (shouldPrevent) {
        if (keyCombo !== "Tab" && keyCombo !== "Shift+Tab" && keyCombo !== "Shift+Enter") {
          e.preventDefault();
          e.stopPropagation();
        }
        this.executeOperation(operation, e);
      }
    }
  }
  /**
   * 判断是否需要阻止默认行为
   * 只有当确实需要自定义处理时才返回 true
   */
  shouldPreventDefault(operation, _e) {
    switch (operation) {
      case "handleBackspace":
        return this.shouldHandleBackspace();
      case "handleDelete":
        return this.shouldHandleDelete();
      case "createNewBlock":
        return true;
      case "insertLineBreak":
        return true;
      case "indentBlock":
      case "outdentBlock":
      case "moveBlockUp":
      case "moveBlockDown":
      case "toggleCollapse":
      case "toggleTodo":
      case "navigateUp":
      case "navigateDown":
      case "undo":
      case "redo":
      case "clearBlockContent":
      case "zoomOut":
      case "zoomIn":
        return true;
      default:
        return false;
    }
  }
  /**
   * 判断 Backspace 是否需要自定义处理
   * 只有当光标在开头时才需要自定义处理（删除块、减少缩进、合并块）
   */
  shouldHandleBackspace() {
    var _a;
    if (((_a = this.settings) == null ? void 0 : _a.editor.renderMode) === "live-preview" && this.editorElement) {
      if (this.editorElement.selectionStart !== void 0) {
        return this.editorElement.selectionStart === 0;
      }
    }
    const selection = window.getSelection();
    if (!selection || selection.rangeCount === 0) {
      return false;
    }
    try {
      const range = selection.getRangeAt(0);
      const cursorPosition = range.startOffset;
      return cursorPosition === 0;
    } catch (error) {
      console.error("[OutlineItem] Error checking backspace position:", error);
      return false;
    }
  }
  /**
   * 判断 Delete 是否需要自定义处理
   * 只有当光标在末尾时才需要自定义处理（删除空块、合并下一个块）
   */
  shouldHandleDelete() {
    var _a;
    if (((_a = this.settings) == null ? void 0 : _a.editor.renderMode) === "live-preview" && this.editorElement) {
      if (this.editorElement.selectionEnd !== void 0) {
        const content = this.editorElement.value || "";
        return this.editorElement.selectionEnd === content.length;
      }
    }
    const selection = window.getSelection();
    if (!selection || selection.rangeCount === 0) {
      return false;
    }
    try {
      const range = selection.getRangeAt(0);
      const cursorPosition = range.startOffset;
      const content = this.contentElement.textContent || "";
      return cursorPosition === content.length;
    } catch (error) {
      console.error("[OutlineItem] Error checking delete position:", error);
      return false;
    }
  }
  /**
   * 执行快捷键操作（借鉴 OutlineItemEnhanced 的焦点恢复逻辑）
   */
  executeOperation(operation, e) {
    var _a;
    const blockId = this.block.id;
    switch (operation) {
      case "createNewBlock":
        this.handleEnter(e);
        break;
      case "insertLineBreak":
        this.handleLineBreak(e);
        break;
      case "handleBackspace":
        this.handleBackspace(e);
        break;
      case "handleDelete":
        this.handleDelete(e);
        break;
      case "indentBlock":
        const contentBefore = this.contentElement.textContent || "";
        if (contentBefore.includes("	")) {
          const cleanContent = contentBefore.replace(/\t/g, "");
          this.contentElement.textContent = cleanContent;
          this.onUpdate(this.block.id, cleanContent);
        }
        if (this.editor.indentBlock(blockId)) {
          this.triggerRenderAndRestoreFocus(blockId);
        }
        break;
      case "outdentBlock":
        const contentBeforeOutdent = this.contentElement.textContent || "";
        if (contentBeforeOutdent.includes("	")) {
          const cleanContent = contentBeforeOutdent.replace(/\t/g, "");
          this.contentElement.textContent = cleanContent;
          this.onUpdate(this.block.id, cleanContent);
        }
        const zoomedBlockId = (_a = this.getZoomedBlockId) == null ? void 0 : _a.call(this);
        if (zoomedBlockId) {
          const allBlocks = getAllBlocks(this.editor.getState().blocks);
          const parentBlock = this.findParentBlock(allBlocks, blockId);
          if (parentBlock && parentBlock.id === zoomedBlockId) {
            break;
          }
        }
        if (this.editor.outdentBlock(blockId)) {
          this.triggerRenderAndRestoreFocus(blockId);
        }
        break;
      case "moveBlockUp":
        if (this.editor.moveBlockUp(blockId)) {
          this.triggerRenderAndRestoreFocus(blockId);
        } else {
        }
        break;
      case "moveBlockDown":
        if (this.editor.moveBlockDown(blockId)) {
          this.triggerRenderAndRestoreFocus(blockId);
        } else {
        }
        break;
      case "toggleCollapse":
        if (this.toggleCollapse()) {
          this.triggerRenderAndRestoreFocus(blockId);
        }
        break;
      case "toggleTodo":
        if (this.editor.toggleTodo(blockId)) {
          this.triggerRenderAndRestoreFocus(blockId);
        }
        break;
      case "navigateUp":
        this.handleNavigateUp(e);
        break;
      case "navigateDown":
        this.handleNavigateDown(e);
        break;
      case "undo":
        if (this.editor.undo()) {
          this.triggerRenderAndRestoreFocus(blockId);
        } else {
        }
        break;
      case "redo":
        if (this.editor.redo()) {
          this.triggerRenderAndRestoreFocus(blockId);
        } else {
        }
        break;
      case "clearBlockContent":
        this.handleClearContent();
        break;
      case "zoomOut":
        this.handleZoomOut();
        break;
      case "zoomIn":
        this.handleZoomIn();
        break;
    }
  }
  /**
   * 触发重新渲染并恢复焦点（借鉴 OutlineItemEnhanced）
   */
  triggerRenderAndRestoreFocus(blockId) {
    if (this.onRender) {
      this.onRender();
      setTimeout(() => {
        this.focusBlockById(blockId);
      }, 10);
    }
  }
  /**
   * 清空当前块内容（Ctrl+Shift+Backspace）
   * 清空后光标应该移动到上一个块的末尾
   */
  handleClearContent() {
    this.contentElement.textContent = "";
    this.onUpdate(this.block.id, "");
    const allBlocks = getAllBlocks(this.editor.getState().blocks);
    const currentIndex = allBlocks.findIndex((b) => b.id === this.block.id);
    if (currentIndex > 0) {
      const prevBlock = allBlocks[currentIndex - 1];
      setTimeout(() => {
        this.focusBlockById(prevBlock.id, "end");
      }, 10);
    } else {
      setTimeout(() => {
        this.contentElement.focus();
      }, 10);
    }
  }
  /**
   * Alt+↑ 处理 - Zoom Out（退出当前 zoom，回到上一层级 zoom 状态）
   */
  handleZoomOut() {
    var _a;
    const zoomedBlockId = (_a = this.getZoomedBlockId) == null ? void 0 : _a.call(this);
    if (!zoomedBlockId) {
      return;
    }
    const allBlocks = getAllBlocks(this.editor.getState().blocks);
    const parentBlock = this.findParentBlock(allBlocks, zoomedBlockId);
    if (parentBlock) {
      if (this.onBulletClick) {
        this.onBulletClick(parentBlock.id);
      }
    } else {
      if (this.onBulletClick) {
        this.onBulletClick(zoomedBlockId);
      }
    }
  }
  /**
   * Alt+↓ 处理 - Zoom In（zoom 到当前聚焦的块，或其第一个子节点）
   */
  handleZoomIn() {
    var _a;
    const zoomedBlockId = (_a = this.getZoomedBlockId) == null ? void 0 : _a.call(this);
    if (zoomedBlockId === this.block.id) {
      if (this.block.children.length > 0) {
        const firstChild = this.block.children[0];
        if (this.onBulletClick) {
          this.onBulletClick(firstChild.id);
        }
      } else {
      }
    } else {
      if (this.onBulletClick) {
        this.onBulletClick(this.block.id);
      }
    }
  }
  /**
   * Enter 键处理 - 创建新块或分割内容
   */
  handleEnter(_e) {
    const selection = window.getSelection();
    if (!selection || selection.rangeCount === 0)
      return;
    const range = selection.getRangeAt(0);
    const content = this.contentElement.textContent || "";
    const beforeRange = document.createRange();
    beforeRange.setStart(this.contentElement, 0);
    beforeRange.setEnd(range.startContainer, range.startOffset);
    const beforeCursor = beforeRange.toString();
    const afterCursor = content.substring(beforeCursor.length);
    const isZoomedBlock = this.getZoomedBlockId && this.getZoomedBlockId() === this.block.id;
    if (afterCursor === "") {
      let newBlock;
      if (isZoomedBlock) {
        newBlock = this.editor.createChildBlock(this.block.id);
      } else {
        newBlock = this.editor.createNewBlock(this.block.id);
      }
      if (this.onRender) {
        this.onRender();
        setTimeout(() => {
          this.focusBlockById(newBlock.id);
        }, 50);
      }
    } else {
      this.contentElement.textContent = beforeCursor;
      this.onUpdate(this.block.id, beforeCursor);
      let newBlock;
      if (isZoomedBlock) {
        newBlock = this.editor.createChildBlock(this.block.id);
      } else {
        newBlock = this.editor.createNewBlock(this.block.id);
      }
      this.onUpdate(newBlock.id, afterCursor);
      if (this.onRender) {
        this.onRender();
        setTimeout(() => {
          this.focusBlockById(newBlock.id);
        }, 50);
      }
    }
  }
  /**
   * Shift+Enter 键处理 - 插入换行符
   */
  handleLineBreak(e) {
    e.preventDefault();
    e.stopPropagation();
    const selection = window.getSelection();
    if (!selection || selection.rangeCount === 0)
      return;
    const range = selection.getRangeAt(0);
    range.deleteContents();
    const textNode = document.createTextNode("\n");
    range.insertNode(textNode);
    range.setStartAfter(textNode);
    range.collapse(true);
    selection.removeAllRanges();
    selection.addRange(range);
    const newContent = this.contentElement.textContent || "";
    this.onUpdate(this.block.id, newContent);
  }
  /**
   * Backspace 键处理 - 参考 HackFlowy 和 OutlineItemEnhanced
   * 注意：此方法只在光标位于开头时被调用（由 shouldHandleBackspace 判断）
   * preventDefault 已在 handleKeyDown 中统一处理
   */
  handleBackspace(e) {
    var _a;
    let content;
    let cursorPosition = null;
    if (((_a = this.settings) == null ? void 0 : _a.editor.renderMode) === "live-preview" && this.editorElement) {
      const textarea = this.editorElement;
      content = textarea.value || "";
      cursorPosition = textarea.selectionStart || 0;
      e.preventDefault();
      e.stopPropagation();
    } else if (this.contentElement) {
      const selection = window.getSelection();
      if (!selection || selection.rangeCount === 0) {
        return;
      }
      try {
        const range = selection.getRangeAt(0);
        cursorPosition = range.startOffset;
        content = this.contentElement.textContent || "";
      } catch (error) {
        console.error("[OutlineItem] Error in handleBackspace:", error);
        return;
      }
    } else {
      console.warn("[OutlineItem] No content element found for backspace");
      return;
    }
    if (cursorPosition !== 0) {
      console.warn("[OutlineItem] Backspace called but cursor not at start");
      return;
    }
    const allBlocks = getAllBlocks(this.editor.getState().blocks);
    const currentIndex = allBlocks.findIndex((b) => b.id === this.block.id);
    const isFirstBlock = currentIndex === 0;
    if (content === "" && this.block.children.length === 0) {
      if (isFirstBlock && allBlocks.length === 1) {
        return;
      }
      this.deleteBlock();
    } else if (content === "" && this.block.level > 0) {
      if (this.editor.outdentBlock(this.block.id)) {
        this.triggerRenderAndRestoreFocus(this.block.id);
      }
    } else {
      if (!isFirstBlock) {
        const prevBlock = allBlocks[currentIndex - 1];
        this.deleteBlock();
        if (this.onRender) {
          this.onRender();
          setTimeout(() => {
            this.focusBlockById(prevBlock.id, "end");
          }, 10);
        }
      } else {
        return;
      }
    }
  }
  /**
   * Delete 键处理
   * 注意：此方法只在光标位于末尾时被调用（由 shouldHandleDelete 判断）
   * preventDefault 已在 handleKeyDown 中统一处理
   */
  handleDelete(e) {
    const selection = window.getSelection();
    if (!selection) {
      return;
    }
    const range = selection.getRangeAt(0);
    const cursorPosition = range.startOffset;
    const content = this.contentElement.textContent || "";
    if (cursorPosition === content.length) {
      if (content === "" && this.block.children.length === 0) {
        this.deleteBlock();
      } else if (content !== "") {
        const allBlocks = getAllBlocks(this.editor.getState().blocks);
        const currentIndex = allBlocks.findIndex((b) => b.id === this.block.id);
        if (currentIndex < allBlocks.length - 1) {
          const nextBlock = allBlocks[currentIndex + 1];
          const mergedContent = content + (nextBlock.content || "");
          this.onUpdate(this.block.id, mergedContent);
          this.editor.deleteBlock(nextBlock.id);
          if (this.onRender) {
            this.onRender();
            setTimeout(() => {
              this.focusBlockById(this.block.id);
            }, 10);
          }
        } else {
        }
      }
    } else {
      console.warn("[OutlineItem] Unexpected: handleDelete called but cursor not at end");
    }
  }
  /**
   * 导航键处理 - 借鉴 OutlineItemEnhanced
   * preventDefault 已在 handleKeyDown 中统一处理
   */
  handleNavigateUp(e) {
    this.focusPreviousBlock();
  }
  handleNavigateDown(e) {
    this.focusNextBlock();
  }
  /**
   * 拖拽事件处理
   */
  handleDragStart(e) {
    var _a;
    e.stopPropagation();
    const multiSelectionManager = (_a = this.getMultiSelectionManager) == null ? void 0 : _a.call(this);
    const selectedBlocks = (multiSelectionManager == null ? void 0 : multiSelectionManager.getSelectedBlocks()) || [];
    const isMultiSelection = selectedBlocks.length > 1 && selectedBlocks.includes(this.block.id);
    if (isMultiSelection) {
      _OutlineItem.currentDraggedId = "multi-selection";
      this.isDragging = true;
      if (e.dataTransfer) {
        e.dataTransfer.effectAllowed = "move";
        multiSelectionManager.startDragSelectedBlocks(e);
        this.createMultiSelectionDragImage(e, selectedBlocks);
        setTimeout(() => {
          selectedBlocks.forEach((blockId) => {
            const element = document.querySelector(`[data-block-id="${blockId}"]`);
            if (element) {
              element.classList.add("dragging");
            }
          });
        }, 0);
      }
    } else {
      _OutlineItem.currentDraggedId = this.block.id;
      this.isDragging = true;
      this.draggedBlock = this.block;
      if (e.dataTransfer) {
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData("text/plain", this.block.id);
        const dragImage = this.element.cloneNode(true);
        dragImage.style.opacity = "0.5";
        document.body.appendChild(dragImage);
        dragImage.style.position = "absolute";
        dragImage.style.top = "-1000px";
        e.dataTransfer.setDragImage(dragImage, 0, 0);
        setTimeout(() => {
          document.body.removeChild(dragImage);
        }, 0);
        setTimeout(() => {
          this.element.classList.add("dragging");
        }, 0);
      }
    }
  }
  handleDragOver(e) {
    var _a;
    e.preventDefault();
    if (e.dataTransfer) {
      e.dataTransfer.dropEffect = "move";
    }
    const draggedId = ((_a = e.dataTransfer) == null ? void 0 : _a.getData("text/plain")) || _OutlineItem.currentDraggedId;
    if (!draggedId || draggedId === this.block.id) {
      return;
    }
    this.clearDragStyles();
    const rect = this.element.getBoundingClientRect();
    const dropZoneHeight = rect.height / 3;
    let dropPosition;
    if (e.clientY < rect.top + dropZoneHeight) {
      dropPosition = "before";
    } else if (e.clientY > rect.bottom - dropZoneHeight) {
      dropPosition = "after";
    } else {
      dropPosition = "child";
    }
    this.showDropZone(rect, dropPosition);
    this.element.classList.add("drag-over-active");
  }
  /**
   * 显示拖拽指示区域 - 完全复用 obsidian-outliner 的实现
   */
  showDropZone(rect, position) {
    if (!_OutlineItem.dropZone || !_OutlineItem.dropZonePadding) {
      return;
    }
    let top;
    if (position === "before") {
      top = rect.top - 2;
    } else {
      top = rect.bottom - 2;
    }
    const container = this.element.closest(".workflowy-editor");
    const containerRect = (container == null ? void 0 : container.getBoundingClientRect()) || rect;
    const containerLeft = containerRect.left + 20;
    let targetLevel = this.block.level;
    if (position === "child") {
      targetLevel = this.block.level + 1;
    }
    const indentWidth = 30;
    const targetIndent = targetLevel * indentWidth;
    const left = containerLeft + targetIndent;
    const width = containerRect.right - left;
    _OutlineItem.dropZone.style.display = "block";
    _OutlineItem.dropZone.style.top = `${top}px`;
    _OutlineItem.dropZone.style.left = `${left}px`;
    _OutlineItem.dropZone.style.width = `${width}px`;
    const dashPadding = 3;
    const dashWidth = indentWidth - dashPadding;
    const accentColor = getComputedStyle(document.body).getPropertyValue("--text-accent").trim() || "#007acc";
    if (targetIndent > 0) {
      _OutlineItem.dropZonePadding.style.width = `${targetIndent}px`;
      _OutlineItem.dropZonePadding.style.marginLeft = `-${targetIndent}px`;
      const svgPattern = `url('data:image/svg+xml,%3Csvg%20viewBox%3D%220%200%20${targetIndent}%204%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cline%20x1%3D%220%22%20y1%3D%220%22%20x2%3D%22${targetIndent}%22%20y2%3D%220%22%20stroke%3D%22${encodeURIComponent(accentColor)}%22%20stroke-width%3D%228%22%20stroke-dasharray%3D%22${dashWidth}%20${dashPadding}%22%2F%3E%3C%2Fsvg%3E')`;
      _OutlineItem.dropZonePadding.style.backgroundImage = svgPattern;
    } else {
      _OutlineItem.dropZonePadding.style.width = "0";
      _OutlineItem.dropZonePadding.style.backgroundImage = "none";
    }
  }
  handleDrop(e) {
    var _a, _b, _c;
    e.preventDefault();
    e.stopPropagation();
    const multiSelectionManager = (_a = this.getMultiSelectionManager) == null ? void 0 : _a.call(this);
    let dragData = null;
    try {
      const dataText = (_b = e.dataTransfer) == null ? void 0 : _b.getData("text/plain");
      if (dataText) {
        dragData = JSON.parse(dataText);
      }
    } catch (e2) {
      const draggedId = (_c = e.dataTransfer) == null ? void 0 : _c.getData("text/plain");
      dragData = { type: "single-block", blockId: draggedId };
    }
    if (!dragData || dragData.type === "single-block" && dragData.blockId === this.block.id) {
      this.clearDragStyles();
      return;
    }
    const rect = this.element.getBoundingClientRect();
    const dropZoneHeight = rect.height / 3;
    let position;
    if (e.clientY < rect.top + dropZoneHeight) {
      position = "before";
    } else if (e.clientY > rect.bottom - dropZoneHeight) {
      position = "after";
    } else {
      position = "child";
    }
    if (dragData.type === "workflowy-multi-blocks") {
      if (multiSelectionManager) {
        multiSelectionManager.handleDropSelectedBlocks(dragData, this.block.id, position);
      }
    } else {
      this.moveBlock(dragData.blockId, this.block.id, position);
    }
    _OutlineItem.currentDraggedId = null;
    this.isDragging = false;
    this.draggedBlock = null;
    this.clearDragStyles();
    if (this.onRender) {
      setTimeout(() => {
        var _a2;
        (_a2 = this.onRender) == null ? void 0 : _a2.call(this);
      }, 50);
    }
  }
  handleDragEnd(e) {
    var _a;
    if (_OutlineItem.currentDraggedId === "multi-selection") {
      const multiSelectionManager = (_a = this.getMultiSelectionManager) == null ? void 0 : _a.call(this);
      const selectedBlocks = (multiSelectionManager == null ? void 0 : multiSelectionManager.getSelectedBlocks()) || [];
      selectedBlocks.forEach((blockId) => {
        const element = document.querySelector(`[data-block-id="${blockId}"]`);
        if (element) {
          element.classList.remove("dragging");
        }
      });
    } else {
      this.element.classList.remove("dragging");
    }
    _OutlineItem.currentDraggedId = null;
    this.isDragging = false;
    this.draggedBlock = null;
    this.clearDragStyles();
    if (this.onRender) {
      setTimeout(() => {
        var _a2;
        (_a2 = this.onRender) == null ? void 0 : _a2.call(this);
      }, 50);
    }
  }
  handleDragLeave(e) {
    if (e.target === this.element) {
      this.clearDragStyles();
    }
  }
  clearDragStyles() {
    if (_OutlineItem.dropZone) {
      _OutlineItem.dropZone.style.display = "none";
    }
    const elementsWithDragStyles = document.querySelectorAll(".drag-over-active");
    elementsWithDragStyles.forEach((el) => {
      el.classList.remove("drag-over-active");
    });
  }
  moveBlock(draggedId, targetId, position) {
    const draggedBlock = findBlockById(this.editor.getState().blocks, draggedId);
    const targetBlock = findBlockById(this.editor.getState().blocks, targetId);
    if (!draggedBlock || !targetBlock) {
      console.error("[OutlineItem] Block not found");
      return;
    }
    if (this.isDescendant(draggedBlock, targetBlock)) {
      console.warn("[OutlineItem] Cannot move block to its own descendant");
      return;
    }
    let newBlocks = this.editor.getState().blocks;
    const parser = this.editor.parser;
    newBlocks = parser.deleteBlock(newBlocks, draggedId);
    if (position === "before") {
      newBlocks = this.insertBlockBefore(newBlocks, draggedBlock, targetId);
    } else if (position === "after") {
      const updatedBlock = this.editor.updateBlockLevel(draggedBlock, targetBlock.level);
      newBlocks = parser.insertBlock(newBlocks, updatedBlock, targetId);
    } else if (position === "child") {
      newBlocks = this.insertBlockAsChild(newBlocks, draggedBlock, targetId);
    }
    this.editor.setState({ blocks: newBlocks });
    if (this.onRender) {
      this.onRender();
    }
  }
  isDescendant(ancestor, descendant) {
    function checkChildren(children) {
      for (const child of children) {
        if (child.id === descendant.id) {
          return true;
        }
        if (checkChildren(child.children)) {
          return true;
        }
      }
      return false;
    }
    return checkChildren(ancestor.children);
  }
  insertBlockBefore(blocks, blockToInsert, targetId) {
    const insert = (blocks2) => {
      const newBlocks = [];
      for (const block of blocks2) {
        if (block.id === targetId) {
          const updatedBlock = this.editor.updateBlockLevel(blockToInsert, block.level);
          newBlocks.push(updatedBlock);
          newBlocks.push(block);
        } else {
          newBlocks.push({
            ...block,
            children: insert(block.children)
          });
        }
      }
      return newBlocks;
    };
    return insert(blocks);
  }
  insertBlockAsChild(blocks, blockToInsert, parentId) {
    return blocks.map((block) => {
      if (block.id === parentId) {
        const updatedBlock = this.editor.updateBlockLevel(blockToInsert, block.level + 1);
        return {
          ...block,
          children: [updatedBlock, ...block.children]
        };
      }
      return {
        ...block,
        children: this.insertBlockAsChild(block.children, blockToInsert, parentId)
      };
    });
  }
  /**
   * 内容变化处理
   */
  handleContentChange() {
    const newContent = this.contentElement.textContent || "";
    this.onUpdate(this.block.id, newContent);
    if (newContent) {
      this.contentElement.removeAttribute("data-placeholder");
    } else {
      this.contentElement.setAttribute("data-placeholder", "\u8F93\u5165\u5185\u5BB9...");
    }
  }
  /**
   * 焦点处理
   */
  handleFocus() {
    this.onFocus(this.block.id);
    this.element.classList.add("focused");
  }
  handleBlur() {
    this.element.classList.remove("focused");
  }
  /**
   * 折叠/展开处理
   */
  toggleCollapse() {
    if (this.editor.toggleCollapse(this.block.id)) {
      this.updateCollapseIndicator();
      if (this.onRender) {
        this.onRender();
      }
      return true;
    }
    return false;
  }
  /**
   * 处理复选框点击
   */
  handleCheckboxClick() {
    if (this.editor.toggleTodo(this.block.id)) {
      this.triggerRenderAndRestoreFocus(this.block.id);
    }
  }
  updateCollapseIndicator() {
    if (this.collapseIndicator) {
      if (this.editor.isCollapsed(this.block.id)) {
        this.collapseIndicator.classList.add("collapsed");
        this.collapseIndicator.innerHTML = "\u25B6";
      } else {
        this.collapseIndicator.classList.remove("collapsed");
        this.collapseIndicator.innerHTML = "\u25BC";
      }
    }
  }
  /**
   * 辅助方法 - 块操作
   */
  deleteBlock() {
    const allBlocks = getAllBlocks(this.editor.getState().blocks);
    const currentIndex = allBlocks.findIndex((b) => b.id === this.block.id);
    let targetBlockId = null;
    if (currentIndex > 0) {
      targetBlockId = allBlocks[currentIndex - 1].id;
    }
    this.editor.deleteBlock(this.block.id);
    if (this.onRender) {
      this.onRender();
      if (targetBlockId) {
        setTimeout(() => {
          this.focusBlockById(targetBlockId);
        }, 10);
      }
    }
  }
  /**
   * 辅助方法 - 焦点导航（借鉴 OutlineItemEnhanced）
   */
  focusPreviousBlock() {
    const allBlocks = getAllBlocks(this.editor.getState().blocks);
    const currentIndex = allBlocks.findIndex((b) => b.id === this.block.id);
    if (currentIndex > 0) {
      const prevBlock = allBlocks[currentIndex - 1];
      this.focusBlockAtStart(prevBlock.id);
    } else {
    }
  }
  focusNextBlock() {
    const allBlocks = getAllBlocks(this.editor.getState().blocks);
    const currentIndex = allBlocks.findIndex((b) => b.id === this.block.id);
    if (currentIndex < allBlocks.length - 1) {
      const nextBlock = allBlocks[currentIndex + 1];
      this.focusBlockAtStart(nextBlock.id);
    } else {
    }
  }
  focusBlockAtStart(blockId) {
    const element = document.querySelector(`[data-block-id="${blockId}"] .workflowy-content`);
    if (element) {
      element.focus();
      const range = document.createRange();
      const selection = window.getSelection();
      if (selection && element.childNodes.length > 0) {
        range.selectNodeContents(element);
        range.collapse(true);
        selection.removeAllRanges();
        selection.addRange(range);
      } else {
        range.setStart(element, 0);
        range.collapse(true);
        selection == null ? void 0 : selection.removeAllRanges();
        selection == null ? void 0 : selection.addRange(range);
      }
    } else {
    }
  }
  focusBlockById(blockId, position = "end") {
    var _a;
    const blockElement = document.querySelector(`[data-block-id="${blockId}"]`);
    if (!blockElement) {
      console.error("[OutlineItem] Block element not found for:", blockId);
      return;
    }
    const displayElement = blockElement.querySelector(".workflowy-content-display");
    if (displayElement) {
      displayElement.click();
      return;
    }
    const element = blockElement.querySelector(".workflowy-content");
    if (element) {
      element.scrollIntoView({ behavior: "smooth", block: "nearest" });
      document.querySelectorAll(".workflowy-item.focused").forEach((el) => {
        el.classList.remove("focused");
      });
      const itemElement = element.closest(".workflowy-item");
      if (itemElement) {
        itemElement.classList.add("focused");
      }
      element.focus();
      const selection = window.getSelection();
      if (selection) {
        const range = document.createRange();
        try {
          if (element.childNodes.length > 0) {
            const textNode = element.childNodes[0];
            if (textNode.nodeType === Node.TEXT_NODE) {
              const textLength = ((_a = textNode.textContent) == null ? void 0 : _a.length) || 0;
              if (position === "end") {
                range.setStart(textNode, textLength);
                range.setEnd(textNode, textLength);
              } else {
                range.setStart(textNode, 0);
                range.setEnd(textNode, 0);
              }
            } else {
              range.selectNodeContents(element);
              range.collapse(position === "start");
            }
          } else {
            range.setStart(element, 0);
            range.setEnd(element, 0);
          }
          selection.removeAllRanges();
          selection.addRange(range);
        } catch (error) {
          console.error("[OutlineItem] Error setting cursor position:", error);
          element.focus();
        }
      } else {
        console.warn("[OutlineItem] No selection object available");
        element.focus();
      }
    } else {
      console.error("[OutlineItem] Element not found for block:", blockId);
      const allElements = document.querySelectorAll(".workflowy-content");
    }
  }
  focusBlockAtPosition(blockId, position) {
    var _a;
    const element = document.querySelector(`[data-block-id="${blockId}"] .workflowy-content`);
    if (element) {
      element.focus();
      const range = document.createRange();
      const selection = window.getSelection();
      if (selection) {
        try {
          const textNode = element.childNodes[0];
          if (textNode && textNode.nodeType === Node.TEXT_NODE) {
            const maxPosition = Math.min(position, ((_a = textNode.textContent) == null ? void 0 : _a.length) || 0);
            range.setStart(textNode, maxPosition);
            range.collapse(true);
          } else {
            range.setStart(element, 0);
            range.collapse(true);
          }
          selection.removeAllRanges();
          selection.addRange(range);
        } catch (error) {
          console.error("[OutlineItem] Error setting cursor position:", error);
          if (element.childNodes.length > 0) {
            range.selectNodeContents(element);
            range.collapse(false);
            selection.removeAllRanges();
            selection.addRange(range);
          }
        }
      }
    } else {
    }
  }
  // ==================== 公共方法 ====================
  getElement() {
    return this.element;
  }
  /**
   * 提供给 EventDelegator 的入口（捕获阶段触发）
   */
  onKeyDownDelegated(e) {
    this.handleKeyDown(e);
  }
  focus() {
    this.contentElement.focus();
  }
  blur() {
    if (this.contentElement) {
      this.contentElement.blur();
    }
  }
  destroy() {
    this.element.remove();
  }
  updateContent(newContent) {
    if (this.contentElement.textContent !== newContent) {
      this.contentElement.textContent = newContent;
      this.handleContentChange();
    }
  }
  setLevel(level) {
    this.block.level = level;
    this.element.style.paddingLeft = `${level * UI_CONFIG.indentSize}px`;
    this.element.setAttribute("data-level", level.toString());
  }
  /**
   * 等待异步渲染完成（如果有）
   */
  async waitForRender() {
    if (this.renderPromise) {
      await this.renderPromise;
    }
  }
  /**
   * 查找父块
   */
  findParentBlock(blocks, targetId, parent = null) {
    for (const block of blocks) {
      if (block.id === targetId) {
        return parent;
      }
      const found = this.findParentBlock(block.children, targetId, block);
      if (found !== null) {
        return found;
      }
    }
    return null;
  }
  /**
   * 创建多选拖拽图像
   */
  createMultiSelectionDragImage(e, selectedBlocks) {
    if (!e.dataTransfer)
      return;
    const dragContainer = document.createElement("div");
    dragContainer.style.cssText = `
            position: absolute;
            top: -1000px;
            left: -1000px;
            background: var(--background-primary);
            border: 2px solid var(--text-accent);
            border-radius: 6px;
            padding: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            font-family: inherit;
            font-size: 12px;
            color: var(--text-normal);
            z-index: 9999;
        `;
    const countLabel = document.createElement("div");
    countLabel.textContent = `\u62D6\u62FD ${selectedBlocks.length} \u4E2A\u8282\u70B9`;
    countLabel.style.cssText = `
            font-weight: 500;
            margin-bottom: 4px;
            color: var(--text-accent);
        `;
    dragContainer.appendChild(countLabel);
    const previewCount = Math.min(3, selectedBlocks.length);
    for (let i = 0; i < previewCount; i++) {
      const blockId = selectedBlocks[i];
      const element = document.querySelector(`[data-block-id="${blockId}"]`);
      if (element) {
        const contentEl = element.querySelector(".workflowy-content");
        const content = (contentEl == null ? void 0 : contentEl.textContent) || "";
        const previewItem = document.createElement("div");
        previewItem.textContent = `\u2022 ${content.slice(0, 20)}${content.length > 20 ? "..." : ""}`;
        previewItem.style.cssText = `
                    opacity: 0.8;
                    margin: 2px 0;
                    font-size: 11px;
                `;
        dragContainer.appendChild(previewItem);
      }
    }
    if (selectedBlocks.length > previewCount) {
      const moreItem = document.createElement("div");
      moreItem.textContent = `... \u8FD8\u6709 ${selectedBlocks.length - previewCount} \u4E2A\u8282\u70B9`;
      moreItem.style.cssText = `
                opacity: 0.6;
                margin: 2px 0;
                font-size: 11px;
                font-style: italic;
            `;
      dragContainer.appendChild(moreItem);
    }
    document.body.appendChild(dragContainer);
    e.dataTransfer.setDragImage(dragContainer, 0, 0);
    setTimeout(() => {
      if (document.body.contains(dragContainer)) {
        document.body.removeChild(dragContainer);
      }
    }, 0);
  }
  /**
   * 使用 Obsidian 渲染器创建非列表项元素
   * 支持标题、代码块、段落、引用等
   */
  async createObsidianRenderedElement() {
    if (!this.app)
      return;
    const rendererContainer = this.element.createDiv({
      cls: "workflowy-obsidian-block"
    });
    this.obsidianRenderer = new ObsidianBlockRenderer(
      this.app,
      this.block,
      rendererContainer,
      this.sourcePath,
      (newContent) => {
        this.block.content = newContent;
        this.onUpdate(this.block.id, newContent);
      }
    );
    await this.obsidianRenderer.render();
    rendererContainer.addEventListener("click", () => {
      this.onFocus(this.block.id);
    });
    this.contentElement = rendererContainer;
  }
  /**
   * ==================== Live Preview 模式方法 ====================
   */
  /**
   * 绑定自动扩展功能
   */
  bindAutoResize() {
    if (!this.editorElement) {
      console.warn("[OutlineItem] bindAutoResize aborted - no editorElement");
      return;
    }
    const autoResize = () => {
      if (!this.editorElement)
        return;
      const originalHeight = this.editorElement.style.height;
      this.editorElement.style.height = "auto";
      const scrollHeight = this.editorElement.scrollHeight;
      this.editorElement.style.height = originalHeight;
      if (scrollHeight > 0) {
        this.editorElement.style.height = scrollHeight + "px";
      }
      this.editorElement.scrollTop = 0;
    };
    this.editorElement.addEventListener("input", autoResize);
    this.editorElement.style.height = "auto";
    this.editorElement.style.height = this.editorElement.scrollHeight + "px";
    this.editorElement.scrollTop = 0;
  }
  /**
   * 绑定双层渲染事件
   */
  bindLivePreviewEvents() {
    if (!this.displayElement || !this.editorElement) {
      return;
    }
    if (this.collapseIndicator) {
      this.collapseIndicator.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.toggleCollapse();
      });
    }
    if (this.checkboxElement) {
      this.checkboxElement.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.handleCheckboxClick();
      });
    }
    this.element.addEventListener("mouseenter", () => {
      this.element.classList.add("hovered");
    });
    this.element.addEventListener("mouseleave", () => {
      this.element.classList.remove("hovered");
    });
    this.bulletElement.setAttribute("draggable", "true");
    this.bulletElement.addEventListener("dragstart", (e) => {
      this.handleDragStart(e);
    });
    this.element.addEventListener("dragover", (e) => this.handleDragOver(e), { capture: true });
    this.element.addEventListener("drop", (e) => this.handleDrop(e), { capture: true });
    this.element.addEventListener("dragend", (e) => this.handleDragEnd(e), { capture: true });
    this.element.addEventListener("dragleave", (e) => this.handleDragLeave(e), { capture: true });
    this.displayElement.addEventListener("click", (e) => {
      const target = e.target;
      if (target.tagName === "A" || target.closest("a")) {
        return;
      }
      this.enterEditMode();
    });
    this.editorElement.addEventListener("input", () => {
      const newContent = this.editorElement.value;
      this.onUpdate(this.block.id, newContent);
    });
    this.editorElement.addEventListener("blur", () => {
      this.exitEditMode();
    });
    this.editorElement.addEventListener("focus", () => {
      this.handleFocus();
    });
    this.editorElement.addEventListener("keydown", (e) => {
      this.handleEditorKeydown(e);
    });
    if (this.app && this.editorElement) {
      this.livePreviewEditor = new LivePreviewEditor(
        this.app,
        this.editorElement
      );
      this.livePreviewEditor.bindShortcuts();
      this.livePreviewEditor.bindContextMenu();
    }
  }
  /**
   * 进入编辑模式
   */
  enterEditMode() {
    if (!this.displayElement || !this.editorElement)
      return;
    const scrollContainer = this.element.closest(".workflowy-editor") || document.documentElement;
    const savedScrollTop = scrollContainer.scrollTop;
    const elementRect = this.element.getBoundingClientRect();
    const containerRect = scrollContainer.getBoundingClientRect();
    const relativeTop = elementRect.top - containerRect.top;
    this.isEditMode = true;
    this.displayElement.style.display = "none";
    this.editorElement.style.display = "block";
    this.editorElement.style.height = "auto";
    this.editorElement.style.height = this.editorElement.scrollHeight + "px";
    this.editorElement.scrollTop = 0;
    this.editorElement.focus();
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        const newElementRect = this.element.getBoundingClientRect();
        const newRelativeTop = newElementRect.top - containerRect.top;
        const scrollDiff = newRelativeTop - relativeTop;
        if (Math.abs(scrollDiff) > 1) {
          scrollContainer.scrollTop = savedScrollTop + scrollDiff;
        }
      });
    });
    this.onFocus(this.block.id);
  }
  /**
   * 退出编辑模式
   */
  exitEditMode() {
    if (!this.displayElement || !this.editorElement)
      return;
    this.isEditMode = false;
    const currentContent = this.editorElement.value;
    if (currentContent !== this.block.content) {
      this.onUpdate(this.block.id, currentContent);
    }
    this.editorElement.style.display = "none";
    this.displayElement.style.display = "block";
    this.renderDisplay();
  }
  /**
   * 渲染显示层（使用 MarkdownRenderer）
   */
  async renderDisplay() {
    var _a;
    if (!this.app || !this.displayElement)
      return;
    this.displayElement.empty();
    const content = ((_a = this.editorElement) == null ? void 0 : _a.value) || this.block.content;
    const tempComponent = new import_obsidian3.Component();
    try {
      await import_obsidian3.MarkdownRenderer.renderMarkdown(
        content,
        this.displayElement,
        this.sourcePath || "",
        tempComponent
      );
      this.enableInternalLinks();
    } catch (error) {
      console.error("[OutlineItem] Error rendering markdown:", error);
      this.displayElement.textContent = content;
    }
  }
  /**
   * 启用内部链接点击
   */
  enableInternalLinks() {
    if (!this.displayElement || !this.app)
      return;
    const links = this.displayElement.querySelectorAll("a.internal-link");
    links.forEach((link) => {
      link.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        const href = link.getAttribute("href");
        if (href) {
          this.app.workspace.openLinkText(href, this.sourcePath || "");
        }
      });
    });
  }
  /**
   * 处理编辑器键盘事件（保留 WorkFlowy 快捷键）
   */
  handleEditorKeydown(e) {
    var _a, _b, _c, _d;
    if (!this.editorElement)
      return;
    const keyCombo = getKeyCombo(e);
    switch (keyCombo) {
      case "Enter":
        e.preventDefault();
        this.handleEnterInEditor();
        break;
      case "Tab":
        e.preventDefault();
        this.editor.indentBlock(this.block.id);
        this.exitEditMode();
        (_a = this.onRender) == null ? void 0 : _a.call(this);
        break;
      case "Shift+Tab":
        e.preventDefault();
        this.editor.outdentBlock(this.block.id);
        this.exitEditMode();
        (_b = this.onRender) == null ? void 0 : _b.call(this);
        break;
      case "Escape":
        e.preventDefault();
        this.exitEditMode();
        break;
      case "Ctrl+ArrowUp":
      case "Cmd+ArrowUp":
        e.preventDefault();
        this.editor.moveBlockUp(this.block.id);
        this.exitEditMode();
        (_c = this.onRender) == null ? void 0 : _c.call(this);
        break;
      case "Ctrl+ArrowDown":
      case "Cmd+ArrowDown":
        e.preventDefault();
        this.editor.moveBlockDown(this.block.id);
        this.exitEditMode();
        (_d = this.onRender) == null ? void 0 : _d.call(this);
        break;
    }
  }
  /**
   * 处理编辑器中的 Enter 键
   */
  handleEnterInEditor() {
    var _a;
    if (!this.editorElement)
      return;
    const cursorPos = this.editorElement.selectionStart;
    const content = this.editorElement.value;
    const beforeCursor = content.substring(0, cursorPos);
    const afterCursor = content.substring(cursorPos);
    this.editorElement.value = beforeCursor;
    this.onUpdate(this.block.id, beforeCursor);
    const newBlock = this.editor.createNewBlock(this.block.id);
    this.onUpdate(newBlock.id, afterCursor);
    this.exitEditMode();
    (_a = this.onRender) == null ? void 0 : _a.call(this);
    setTimeout(() => {
      this.focusAndEditBlock(newBlock.id);
    }, 150);
  }
  /**
   * 聚焦并进入块的编辑模式（Live Preview 专用）
   */
  focusAndEditBlock(blockId) {
    const blockElement = document.querySelector(`[data-block-id="${blockId}"]`);
    if (blockElement) {
      const displayElement = blockElement.querySelector(".workflowy-content-display");
      if (displayElement) {
        displayElement.click();
      } else {
        const contentElement = blockElement.querySelector(".workflowy-content");
        if (contentElement) {
          contentElement.focus();
        }
      }
    }
  }
};
var OutlineItem = _OutlineItem;
// 拖拽相关状态
// 全局记录当前拖拽中的块ID（解决部分环境 dragover 读取不到 dataTransfer 的问题）
OutlineItem.currentDraggedId = null;
// 拖拽指示元素 - 复用 obsidian-outliner 的实现
OutlineItem.dropZone = null;
OutlineItem.dropZonePadding = null;

// src/isolation/view-state-manager.ts
var ViewStateManager = class {
  constructor() {
    this.viewStates = /* @__PURE__ */ new Map();
    this.leafToViewType = /* @__PURE__ */ new WeakMap();
  }
  /**
   * 获取单例实例
   */
  static getInstance() {
    if (!ViewStateManager.instance) {
      ViewStateManager.instance = new ViewStateManager();
    }
    return ViewStateManager.instance;
  }
  /**
   * 重置管理器（用于测试和清理）
   */
  static reset() {
    if (ViewStateManager.instance) {
      ViewStateManager.instance.viewStates.clear();
      ViewStateManager.instance = null;
    }
  }
  /**
   * 注册视图
   */
  registerView(leaf, viewType, filePath) {
    var _a;
    const leafId = this.getLeafId(leaf);
    const now = Date.now();
    const isActive = ((_a = leaf.workspace) == null ? void 0 : _a.activeLeaf) === leaf;
    this.viewStates.set(leafId, {
      leafId,
      viewType,
      filePath,
      isActive: isActive || false,
      createdAt: now,
      lastAccessedAt: now
    });
    this.leafToViewType.set(leaf, viewType);
  }
  /**
   * 注销视图
   */
  unregisterView(leaf) {
    const leafId = this.getLeafId(leaf);
    this.viewStates.delete(leafId);
    this.leafToViewType.delete(leaf);
  }
  /**
   * 更新视图状态
   */
  updateViewState(leaf, updates) {
    const leafId = this.getLeafId(leaf);
    const currentState = this.viewStates.get(leafId);
    if (currentState) {
      this.viewStates.set(leafId, {
        ...currentState,
        ...updates,
        lastAccessedAt: Date.now()
      });
    }
  }
  /**
   * 获取视图类型
   */
  getViewType(leaf) {
    if (!leaf) {
      return "other" /* OTHER */;
    }
    const view = leaf.view;
    if (!view) {
      return "other" /* OTHER */;
    }
    const viewType = view.getViewType();
    if (viewType === WORKFLOWY_VIEW_TYPE) {
      return "workflowy-view" /* WORKFLOWY */;
    } else if (viewType === "markdown") {
      return "markdown" /* MARKDOWN */;
    } else {
      return "other" /* OTHER */;
    }
  }
  /**
   * 检查是否在 Workflowy 视图中
   */
  isInWorkflowyView(leaf) {
    return this.getViewType(leaf) === "workflowy-view" /* WORKFLOWY */;
  }
  /**
   * 检查是否在 Markdown 视图中
   */
  isInMarkdownView(leaf) {
    return this.getViewType(leaf) === "markdown" /* MARKDOWN */;
  }
  /**
   * 获取当前活动视图类型
   */
  getActiveViewType(workspace) {
    const activeLeaf = workspace.activeLeaf;
    return this.getViewType(activeLeaf);
  }
  /**
   * 获取所有 Workflowy 视图
   */
  getAllWorkflowyViews() {
    return Array.from(this.viewStates.values()).filter((state) => state.viewType === "workflowy-view" /* WORKFLOWY */);
  }
  /**
   * 获取视图状态
   */
  getViewState(leaf) {
    const leafId = this.getLeafId(leaf);
    return this.viewStates.get(leafId);
  }
  /**
   * 检查是否有任何 Workflowy 视图处于活动状态
   */
  hasActiveWorkflowyView() {
    return Array.from(this.viewStates.values()).some((state) => state.viewType === "workflowy-view" /* WORKFLOWY */ && state.isActive);
  }
  /**
   * 获取视图统计信息
   */
  getStatistics() {
    const stats = {
      total: 0,
      workflowy: 0,
      markdown: 0,
      other: 0
    };
    for (const state of this.viewStates.values()) {
      stats.total++;
      if (state.viewType === "workflowy-view" /* WORKFLOWY */) {
        stats.workflowy++;
      } else if (state.viewType === "markdown" /* MARKDOWN */) {
        stats.markdown++;
      } else {
        stats.other++;
      }
    }
    return stats;
  }
  /**
   * 生成 leaf 的唯一标识符
   */
  getLeafId(leaf) {
    return leaf.id || `leaf-${Date.now()}-${Math.random()}`;
  }
  /**
   * 调试：打印当前状态
   */
  debugPrintState() {
  }
};

// src/isolation/isolation-layer.ts
var IsolationViolationType = /* @__PURE__ */ ((IsolationViolationType2) => {
  IsolationViolationType2["COMMAND_IN_WRONG_VIEW"] = "command_in_wrong_view";
  IsolationViolationType2["EVENT_LEAKED"] = "event_leaked";
  IsolationViolationType2["STYLE_LEAKED"] = "style_leaked";
  IsolationViolationType2["API_MISUSE"] = "api_misuse";
  IsolationViolationType2["STATE_CORRUPTION"] = "state_corruption";
  return IsolationViolationType2;
})(IsolationViolationType || {});
var IsolationLayer = class {
  // 严格模式：发现违规时抛出错误
  constructor() {
    this.violations = [];
    this.strictMode = true;
    this.viewStateManager = ViewStateManager.getInstance();
  }
  /**
   * 获取单例实例
   */
  static getInstance() {
    if (!IsolationLayer.instance) {
      IsolationLayer.instance = new IsolationLayer();
    }
    return IsolationLayer.instance;
  }
  /**
   * 设置严格模式
   */
  setStrictMode(strict) {
    this.strictMode = strict;
  }
  /**
   * 检查命令是否可以执行
   */
  checkCommandExecution(commandId, requiredViewType, currentLeaf) {
    const currentViewType = this.viewStateManager.getViewType(currentLeaf);
    if (currentViewType !== requiredViewType) {
      const violation = {
        type: "command_in_wrong_view" /* COMMAND_IN_WRONG_VIEW */,
        message: `Command '${commandId}' requires ${requiredViewType} view but executed in ${currentViewType} view`,
        context: { commandId, requiredViewType, currentViewType },
        timestamp: Date.now(),
        stackTrace: this.captureStackTrace()
      };
      this.recordViolation(violation);
      return {
        allowed: false,
        reason: violation.message,
        violation
      };
    }
    return { allowed: true };
  }
  /**
   * 检查事件是否应该被处理
   */
  checkEventHandling(event, requiredContext) {
    const target = event.target;
    if (requiredContext === "workflowy-container") {
      if (!this.isElementInWorkflowyContainer(target)) {
        const violation = {
          type: "event_leaked" /* EVENT_LEAKED */,
          message: `Event '${event.type}' handled outside Workflowy container`,
          context: { eventType: event.type, targetElement: target.className },
          timestamp: Date.now(),
          stackTrace: this.captureStackTrace()
        };
        this.recordViolation(violation);
        return {
          allowed: false,
          reason: violation.message,
          violation
        };
      }
    }
    return { allowed: true };
  }
  /**
   * 检查 API 调用是否合法
   */
  checkAPICall(apiName, callerView, requiredView) {
    if (callerView !== requiredView) {
      const violation = {
        type: "api_misuse" /* API_MISUSE */,
        message: `API '${apiName}' requires ${requiredView} view but called from ${callerView} view`,
        context: { apiName, callerView, requiredView },
        timestamp: Date.now(),
        stackTrace: this.captureStackTrace()
      };
      this.recordViolation(violation);
      return {
        allowed: false,
        reason: violation.message,
        violation
      };
    }
    return { allowed: true };
  }
  /**
   * 检查样式是否应该应用
   */
  checkStyleApplication(selector) {
    if (this.isWorkflowyStyleSelector(selector)) {
      if (!selector.startsWith(".workflowy-container") && !selector.includes(".workflowy-container ")) {
        const violation = {
          type: "style_leaked" /* STYLE_LEAKED */,
          message: `Style selector '${selector}' not properly scoped to .workflowy-container`,
          context: { selector },
          timestamp: Date.now(),
          stackTrace: this.captureStackTrace()
        };
        this.recordViolation(violation);
        return {
          allowed: false,
          reason: violation.message,
          violation
        };
      }
    }
    return { allowed: true };
  }
  /**
   * 验证视图状态一致性
   */
  validateViewState(leaf, expectedType) {
    const actualType = this.viewStateManager.getViewType(leaf);
    if (actualType !== expectedType) {
      const violation = {
        type: "state_corruption" /* STATE_CORRUPTION */,
        message: `View state mismatch: expected ${expectedType}, got ${actualType}`,
        context: { expectedType, actualType },
        timestamp: Date.now(),
        stackTrace: this.captureStackTrace()
      };
      this.recordViolation(violation);
      return {
        allowed: false,
        reason: violation.message,
        violation
      };
    }
    return { allowed: true };
  }
  /**
   * 安全执行 Workflowy 操作
   */
  safeExecuteWorkflowyAction(leaf, action, actionName = "unknown") {
    if (!leaf) {
      console.warn(`[IsolationLayer] Cannot execute '${actionName}': no leaf provided`);
      return false;
    }
    const checkResult = this.checkCommandExecution(
      actionName,
      "workflowy-view" /* WORKFLOWY */,
      leaf
    );
    if (!checkResult.allowed) {
      if (this.strictMode) {
        throw new Error(`Isolation violation: ${checkResult.reason}`);
      }
      console.error(`[IsolationLayer] Action '${actionName}' blocked:`, checkResult.reason);
      return false;
    }
    try {
      action();
      return true;
    } catch (error) {
      console.error(`[IsolationLayer] Error executing '${actionName}':`, error);
      return false;
    }
  }
  /**
   * 检查是否应该显示菜单项
   */
  shouldShowMenuItem(leaf, menuItemFor) {
    if (!leaf)
      return false;
    const viewType = this.viewStateManager.getViewType(leaf);
    if (menuItemFor === "workflowy") {
      return viewType === "markdown" /* MARKDOWN */;
    } else {
      return viewType === "workflowy-view" /* WORKFLOWY */;
    }
  }
  /**
   * 元素是否在 Workflowy 容器内
   */
  isElementInWorkflowyContainer(element) {
    return element.closest(".workflowy-container") !== null;
  }
  /**
   * 创建隔离的样式选择器
   */
  createIsolatedStyleSelector(selector) {
    if (selector.startsWith(".workflowy-container")) {
      return selector;
    }
    return `.workflowy-container ${selector}`;
  }
  /**
   * 阻止事件泄露
   */
  preventEventLeakage(event) {
    const target = event.target;
    if (!this.isElementInWorkflowyContainer(target)) {
      event.stopPropagation();
      event.preventDefault();
      const violation = {
        type: "event_leaked" /* EVENT_LEAKED */,
        message: `Event '${event.type}' prevented from leaking outside Workflowy container`,
        context: { eventType: event.type },
        timestamp: Date.now()
      };
      this.recordViolation(violation);
    }
  }
  /**
   * 获取所有违规记录
   */
  getViolations() {
    return [...this.violations];
  }
  /**
   * 清除违规记录
   */
  clearViolations() {
    this.violations = [];
  }
  /**
   * 获取违规统计
   */
  getViolationStats() {
    const stats = {};
    for (const type of Object.values(IsolationViolationType)) {
      stats[type] = 0;
    }
    for (const violation of this.violations) {
      stats[violation.type]++;
    }
    return stats;
  }
  /**
   * 记录违规
   */
  recordViolation(violation) {
    this.violations.push(violation);
    console.warn("[IsolationLayer] Violation detected:", violation);
    if (this.violations.length > 1e3) {
      this.violations = this.violations.slice(-1e3);
    }
  }
  /**
   * 捕获堆栈跟踪
   */
  captureStackTrace() {
    const stack = new Error().stack;
    return stack || "Stack trace not available";
  }
  /**
   * 判断选择器是否是 Workflowy 样式
   */
  isWorkflowyStyleSelector(selector) {
    const workflowyPrefixes = [
      ".workflowy",
      ".block-",
      ".collapse-",
      ".outline-"
    ];
    return workflowyPrefixes.some((prefix) => selector.includes(prefix));
  }
  /**
   * 调试：打印隔离状态
   */
  debugPrintState() {
  }
};

// src/isolation/event-delegator.ts
var EventDelegator = class {
  constructor() {
    this.registeredEvents = /* @__PURE__ */ new Map();
    this.eventLogs = [];
    this.maxLogSize = 500;
    this.globalHandlers = /* @__PURE__ */ new Map();
    this.isolationLayer = IsolationLayer.getInstance();
  }
  /**
   * 获取单例实例
   */
  static getInstance() {
    if (!EventDelegator.instance) {
      EventDelegator.instance = new EventDelegator();
    }
    return EventDelegator.instance;
  }
  /**
   * 注册事件委托
   */
  registerEvent(eventType, containerSelector, handler, options) {
    const event = {
      type: eventType,
      handler,
      containerSelector,
      options
    };
    if (!this.registeredEvents.has(eventType)) {
      this.registeredEvents.set(eventType, []);
      this.setupGlobalHandler(eventType);
    }
    this.registeredEvents.get(eventType).push(event);
  }
  /**
   * 注销事件委托
   */
  unregisterEvent(eventType, containerSelector) {
    const events = this.registeredEvents.get(eventType);
    if (!events)
      return;
    const filtered = events.filter((e) => e.containerSelector !== containerSelector);
    if (filtered.length === 0) {
      this.registeredEvents.delete(eventType);
      this.removeGlobalHandler(eventType);
    } else {
      this.registeredEvents.set(eventType, filtered);
    }
  }
  /**
   * 设置全局事件处理器
   */
  setupGlobalHandler(eventType) {
    const handler = (e) => {
      this.handleGlobalEvent(e);
    };
    this.globalHandlers.set(eventType, handler);
    document.addEventListener(eventType, handler, true);
  }
  /**
   * 移除全局事件处理器
   */
  removeGlobalHandler(eventType) {
    const handler = this.globalHandlers.get(eventType);
    if (handler) {
      document.removeEventListener(eventType, handler, true);
      this.globalHandlers.delete(eventType);
    }
  }
  /**
   * 处理全局事件
   */
  handleGlobalEvent(event) {
    const eventType = event.type;
    const events = this.registeredEvents.get(eventType);
    if (!events)
      return;
    const target = event.target;
    for (const delegatedEvent of events) {
      const container = document.querySelector(delegatedEvent.containerSelector);
      if (!container)
        continue;
      const activeEl = document.activeElement || null;
      const isKeyboardEvent = eventType === "keydown" || eventType === "keypress" || eventType === "keyup";
      const inContainerByTarget = container.contains(target);
      const inContainerByActive = isKeyboardEvent && !!activeEl && container.contains(activeEl);
      const inContainer = inContainerByTarget || inContainerByActive;
      if (inContainer) {
        const checkResult = this.isolationLayer.checkEventHandling(
          event,
          "workflowy-container"
        );
        if (checkResult.allowed) {
          try {
            event._wfActiveElement = inContainerByActive ? activeEl : void 0;
            delegatedEvent.handler(event);
            this.logEvent(eventType, target && target.className || "unknown", true, false);
          } catch (error) {
            console.error(`[EventDelegator] Error handling ${eventType}:`, error);
            this.logEvent(eventType, target && target.className || "unknown", false, false, String(error));
          }
        } else {
          this.logEvent(eventType, target && target.className || "unknown", false, true, checkResult.reason);
          event.stopPropagation();
          event.preventDefault();
        }
        break;
      }
    }
  }
  /**
   * 创建隔离的事件监听器
   */
  createIsolatedEventListener(element, eventType, handler, requiredContainer = ".workflowy-container") {
    return (event) => {
      const target = event.target;
      if (!target.closest(requiredContainer)) {
        console.warn(`[EventDelegator] Event ${eventType} blocked: not in ${requiredContainer}`);
        this.logEvent(eventType, target.className, false, true, `Not in ${requiredContainer}`);
        event.stopPropagation();
        event.preventDefault();
        return;
      }
      try {
        handler(event);
        this.logEvent(eventType, target.className, true, false);
      } catch (error) {
        console.error(`[EventDelegator] Error in isolated listener:`, error);
        this.logEvent(eventType, target.className, false, false, String(error));
      }
    };
  }
  /**
   * 批量注册 Workflowy 事件
   */
  registerWorkflowyEvents(containerElement, eventHandlers) {
    for (const [eventType, handler] of Object.entries(eventHandlers)) {
      const isolatedHandler = this.createIsolatedEventListener(
        containerElement,
        eventType,
        handler
      );
      containerElement.addEventListener(eventType, isolatedHandler);
    }
  }
  /**
   * 清理容器的所有事件
   */
  cleanupContainerEvents(containerSelector) {
    for (const eventType of this.registeredEvents.keys()) {
      this.unregisterEvent(eventType, containerSelector);
    }
  }
  /**
   * 获取事件日志
   */
  getEventLogs() {
    return [...this.eventLogs];
  }
  /**
   * 获取被阻止的事件统计
   */
  getBlockedEventStats() {
    const stats = {};
    for (const log of this.eventLogs) {
      if (log.blocked) {
        stats[log.eventType] = (stats[log.eventType] || 0) + 1;
      }
    }
    return stats;
  }
  /**
   * 清除事件日志
   */
  clearLogs() {
    this.eventLogs = [];
  }
  /**
   * 记录事件
   */
  logEvent(eventType, targetElement, handled, blocked, reason) {
    const log = {
      eventType,
      timestamp: Date.now(),
      targetElement,
      handled,
      blocked,
      reason
    };
    this.eventLogs.push(log);
    if (this.eventLogs.length > this.maxLogSize) {
      this.eventLogs = this.eventLogs.slice(-this.maxLogSize);
    }
  }
  /**
   * 调试：打印状态
   */
  debugPrintState() {
  }
  /**
   * 清理所有事件
   */
  cleanup() {
    for (const eventType of this.globalHandlers.keys()) {
      this.removeGlobalHandler(eventType);
    }
    this.registeredEvents.clear();
    this.eventLogs = [];
  }
};

// src/features/vertical-lines.ts
var VerticalLinesManager = class {
  // 缓存 200ms
  constructor(container, editor, onToggleCollapse) {
    this.lines = [];
    this.lineElements = [];
    // 方案C：节流机制 - 避免短时间内多次更新
    this.updateTimer = null;
    this.pendingUpdate = false;
    // 方案C：缓存机制 - 缓存 DOM 查询结果
    this.blockElementCache = /* @__PURE__ */ new Map();
    this.cacheTimeout = 200;
    /**
     * 处理点击事件 - 复用 obsidian-outliner 的点击逻辑
     */
    this.onClick = (e) => {
      e.preventDefault();
      const clickedElement = e.target;
      const lineIndex = Number(clickedElement.dataset.index);
      const line = this.lines[lineIndex];
      if (line) {
        this.toggleFolding(line);
      }
    };
    this.editor = editor;
    this.onToggleCollapse = onToggleCollapse;
    if (getComputedStyle(container).position === "static") {
      container.style.position = "relative";
    }
    this.prepareDom(container);
  }
  /**
   * 创建DOM容器 - 复用 obsidian-outliner 的结构
   */
  prepareDom(container) {
    this.contentContainer = document.createElement("div");
    this.contentContainer.classList.add("workflowy-vertical-lines-content-container");
    this.scroller = document.createElement("div");
    this.scroller.classList.add("workflowy-vertical-lines-scroller");
    this.scroller.appendChild(this.contentContainer);
    container.appendChild(this.scroller);
    this.scroller.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 1;
            overflow: hidden;
        `;
    this.contentContainer.style.cssText = `
            position: relative;
            width: 100%;
            height: 100%;
        `;
  }
  /**
   * 更新垂直线 - 主入口方法（方案C：节流优化）
   * 避免短时间内多次调用，合并为一次更新
   */
  update() {
    if (this.updateTimer !== null || this.pendingUpdate) {
      return;
    }
    this.performUpdate();
    this.updateTimer = window.setTimeout(() => {
      this.updateTimer = null;
      this.pendingUpdate = false;
    }, 50);
  }
  /**
   * 执行实际更新
   */
  performUpdate() {
    this.calculate();
    this.updateDom();
  }
  /**
   * 计算垂直线位置 - 避免重复计算
   */
  calculate() {
    this.lines = [];
    const state = this.editor.getState();
    this.processBlocks(state.blocks);
    this.lines.sort(
      (a, b) => a.top === b.top ? a.left - b.left : a.top - b.top
    );
  }
  /**
   * 递归处理块列表
   */
  processBlocks(blocks) {
    for (const block of blocks) {
      if (block.children.length > 0 && !this.editor.isCollapsed(block.id)) {
        this.calculateLineForBlock(block);
        this.processBlocks(block.children);
      }
    }
  }
  /**
   * 为单个块计算垂直线
   */
  calculateLineForBlock(block) {
    const blockElement = this.getBlockElement(block.id);
    if (!blockElement) {
      return;
    }
    const rect = blockElement.getBoundingClientRect();
    const containerRect = this.scroller.parentElement.getBoundingClientRect();
    const displayLevel = parseInt(blockElement.getAttribute("data-level") || "0");
    const left = displayLevel * UI_CONFIG.indentSize + 23;
    const top = rect.top - containerRect.top;
    const lastVisibleChild = this.findLastVisibleChild(block);
    let bottom = rect.bottom - containerRect.top;
    if (lastVisibleChild) {
      const lastChildElement = this.getBlockElement(lastVisibleChild.id);
      if (lastChildElement) {
        const lastChildRect = lastChildElement.getBoundingClientRect();
        bottom = lastChildRect.bottom - containerRect.top;
      }
    }
    const height = bottom - top - 28;
    if (height > 20) {
      this.lines.push({
        top: top + 28,
        // 28px 是内容行的高度偏移
        left,
        height: `${height}px`,
        blockId: block.id,
        block
      });
    }
  }
  /**
   * 查找块对应的DOM元素
   */
  getBlockElement(blockId) {
    var _a;
    const cached = this.blockElementCache.get(blockId);
    if (cached && document.body.contains(cached)) {
      return cached;
    }
    const element = (_a = this.scroller.parentElement) == null ? void 0 : _a.querySelector(
      `[data-block-id="${blockId}"]`
    );
    if (element) {
      this.blockElementCache.set(blockId, element);
      setTimeout(() => {
        this.blockElementCache.delete(blockId);
      }, this.cacheTimeout);
    }
    return element;
  }
  /**
   * 递归查找最后一个可见的子项
   */
  findLastVisibleChild(block) {
    if (block.children.length === 0) {
      return null;
    }
    const lastChild = block.children[block.children.length - 1];
    if (lastChild.children.length > 0 && !this.editor.isCollapsed(lastChild.id)) {
      const deepestChild = this.findLastVisibleChild(lastChild);
      return deepestChild || lastChild;
    }
    return lastChild;
  }
  /**
   * 检查是否有下一个兄弟节点
   */
  hasNextSibling(block) {
    const allBlocks = getAllBlocks(this.editor.getState().blocks);
    const currentIndex = allBlocks.findIndex((b) => b.id === block.id);
    if (currentIndex === -1 || currentIndex === allBlocks.length - 1) {
      return false;
    }
    const nextBlock = allBlocks[currentIndex + 1];
    return nextBlock.level === block.level;
  }
  /**
   * 更新DOM - 复用 obsidian-outliner 的DOM更新逻辑
   */
  updateDom() {
    const parentElement = this.scroller.parentElement;
    if (parentElement) {
      this.contentContainer.style.height = parentElement.scrollHeight + "px";
    }
    for (let i = 0; i < this.lines.length; i++) {
      if (this.lineElements.length === i) {
        const e2 = document.createElement("div");
        e2.classList.add("workflowy-vertical-line");
        e2.dataset.index = String(i);
        e2.addEventListener("mousedown", this.onClick);
        this.contentContainer.appendChild(e2);
        this.lineElements.push(e2);
      }
      const l = this.lines[i];
      const e = this.lineElements[i];
      e.style.top = Math.round(l.top) + "px";
      e.style.left = Math.round(l.left) + "px";
      e.style.height = l.height;
      e.style.display = "block";
    }
    for (let i = this.lines.length; i < this.lineElements.length; i++) {
      const e = this.lineElements[i];
      e.style.top = "0px";
      e.style.left = "0px";
      e.style.height = "0px";
      e.style.display = "none";
    }
  }
  /**
   * 切换折叠状态 - 完全复用 obsidian-outliner 的折叠逻辑
   * 
   * 逻辑说明：
   * 1. 获取当前块的所有直接子项
   * 2. 检查所有子项的折叠状态
   * 3. 如果所有子项都已折叠 → 展开所有子项
   * 4. 如果有任何子项未折叠 → 折叠所有子项
   * 
   * 重要：当前块本身不会被折叠，只折叠/展开其直接子项
   */
  toggleFolding(line) {
    const { block } = line;
    if (block.children.length === 0) {
      return;
    }
    let needToUnfold = true;
    const blocksToToggle = [];
    for (const child of block.children) {
      if (!child.content || child.content.trim() === "") {
        continue;
      }
      if (!this.editor.isCollapsed(child.id)) {
        needToUnfold = false;
      }
      blocksToToggle.push(child.id);
    }
    for (const blockId of blocksToToggle) {
      if (needToUnfold) {
        this.editor.expand(blockId);
      } else {
        this.editor.collapse(blockId);
      }
    }
    this.onToggleCollapse(block.id);
  }
  /**
   * 销毁垂直线管理器
   */
  destroy() {
    if (this.updateTimer !== null) {
      clearTimeout(this.updateTimer);
      this.updateTimer = null;
    }
    this.blockElementCache.clear();
    this.lineElements.forEach((element) => element.remove());
    this.lineElements = [];
    this.lines = [];
    if (this.scroller.parentElement) {
      this.scroller.remove();
    }
  }
};

// src/features/multi-selection.ts
var MultiSelectionManager = class {
  constructor(container, editor, onSelectionChange, onRender) {
    this.selectedBlocks = /* @__PURE__ */ new Set();
    this.isSelecting = false;
    this.selectionStart = null;
    this.selectionBox = null;
    this.justFinishedSelecting = false;
    this.selectionCounter = null;
    this.updateThrottleTimer = null;
    this.container = container;
    this.editor = editor;
    this.onSelectionChange = onSelectionChange;
    this.onRender = onRender;
    this.bindEvents();
    this.createSelectionBox();
    this.createSelectionCounter();
  }
  /**
   * 创建选择框元素
   */
  createSelectionBox() {
    this.selectionBox = document.createElement("div");
    this.selectionBox.className = "workflowy-selection-box";
    this.selectionBox.style.cssText = `
            position: absolute;
            border: 2px dashed var(--text-accent);
            background: rgba(var(--color-accent-rgb), 0.1);
            pointer-events: none;
            z-index: 1000;
            display: none;
        `;
    document.body.appendChild(this.selectionBox);
  }
  /**
   * 创建选择计数器元素
   */
  createSelectionCounter() {
    this.selectionCounter = document.createElement("div");
    this.selectionCounter.className = "workflowy-selection-counter";
    this.selectionCounter.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--background-secondary);
            border: 1px solid var(--background-modifier-border);
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 12px;
            color: var(--text-muted);
            z-index: 1001;
            display: none;
        `;
    document.body.appendChild(this.selectionCounter);
  }
  /**
   * 更新选择计数器
   */
  updateSelectionCounter() {
    if (!this.selectionCounter)
      return;
    const count = this.selectedBlocks.size;
    if (count > 0) {
      this.selectionCounter.textContent = `\u5DF2\u9009\u62E9 ${count} \u4E2A\u8282\u70B9`;
      this.selectionCounter.style.display = "block";
    } else {
      this.selectionCounter.style.display = "none";
    }
  }
  /**
   * 绑定事件监听器
   */
  bindEvents() {
    this.container.addEventListener("mousedown", this.handleMouseDown.bind(this), true);
    document.addEventListener("mousemove", this.handleMouseMove.bind(this));
    document.addEventListener("mouseup", this.handleMouseUp.bind(this));
    this.boundKeyDownHandler = this.handleKeyDown.bind(this);
    document.addEventListener("keydown", this.boundKeyDownHandler, true);
    this.container.addEventListener("click", this.handleContainerClick.bind(this));
  }
  /**
   * 处理鼠标按下事件
   */
  handleMouseDown(e) {
    if (e.button !== 0)
      return;
    const target = e.target;
    const bulletElement = target.closest(".workflowy-bullet");
    if (bulletElement) {
      return;
    }
    const contentElement = target.closest(".workflowy-content, .workflowy-content-display, .workflowy-content-editor");
    if (!contentElement) {
      return;
    }
    if (target.classList.contains("workflowy-collapse") || target.classList.contains("workflowy-vertical-line") || target.closest(".workflowy-collapse")) {
      return;
    }
    let blockElement = contentElement.closest("[data-block-id]");
    if (!blockElement) {
      const blockId2 = contentElement.getAttribute("data-block-id");
      if (blockId2) {
        blockElement = contentElement;
      } else {
        return;
      }
    }
    const blockId = blockElement.dataset.blockId || blockElement.getAttribute("data-block-id");
    if (!blockId)
      return;
    if (e.ctrlKey || e.metaKey) {
      this.toggleBlockSelection(blockId);
      e.preventDefault();
      e.stopPropagation();
      return;
    }
    if (this.selectedBlocks.has(blockId)) {
      return;
    }
    this.clearSelection();
    this.isSelecting = true;
    this.selectionStart = { x: e.clientX, y: e.clientY };
    this.selectionStart.startBlockId = blockId;
    this.selectionStart.startElement = blockElement;
  }
  /**
   * 处理鼠标移动事件
   */
  handleMouseMove(e) {
    if (!this.isSelecting || !this.selectionStart) {
      return;
    }
    const deltaY = e.clientY - this.selectionStart.y;
    const minDragDistance = 8;
    if (Math.abs(deltaY) < minDragDistance) {
      return;
    }
    e.preventDefault();
    this.container.classList.add("selecting");
    if (this.selectionBox) {
      this.selectionBox.style.display = "block";
      this.selectionBox.style.left = `${this.selectionStart.x - 2}px`;
      this.selectionBox.style.top = `${Math.min(this.selectionStart.y, e.clientY)}px`;
      this.selectionBox.style.width = "4px";
      this.selectionBox.style.height = `${Math.abs(deltaY)}px`;
    }
    if (this.updateThrottleTimer !== null) {
      return;
    }
    this.updateThrottleTimer = window.setTimeout(() => {
      this.updateThrottleTimer = null;
    }, 16);
    this.updateSelectionFromVerticalDrag(e.clientY);
  }
  /**
   * 处理鼠标释放事件
   */
  handleMouseUp(e) {
    if (this.isSelecting) {
      this.container.classList.remove("selecting");
      if (this.selectionBox) {
        this.selectionBox.style.display = "none";
      }
      if (this.selectedBlocks.size === 0) {
        this.isSelecting = false;
        this.selectionStart = null;
        return;
      }
      this.isSelecting = false;
      this.selectionStart = null;
      this.justFinishedSelecting = true;
      setTimeout(() => {
        this.justFinishedSelecting = false;
      }, 300);
    }
  }
  /**
   * 基于垂直拖拽更新选择的节点
   */
  updateSelectionFromVerticalDrag(currentY) {
    if (!this.selectionStart)
      return;
    const startBlockId = this.selectionStart.startBlockId;
    const startElement = this.selectionStart.startElement;
    if (!startBlockId || !startElement)
      return;
    const blockElements = Array.from(this.container.querySelectorAll("[data-block-id]"));
    const sortedElements = blockElements.map((element) => ({
      element,
      blockId: element.dataset.blockId,
      rect: element.getBoundingClientRect()
    })).filter((item) => item.blockId).sort((a, b) => a.rect.top - b.rect.top);
    if (sortedElements.length === 0)
      return;
    let currentBlockId = null;
    let minDistance = Infinity;
    for (const item of sortedElements) {
      const rect = item.rect;
      const centerY = rect.top + rect.height / 2;
      const distance = Math.abs(centerY - currentY);
      if (distance < minDistance) {
        minDistance = distance;
        currentBlockId = item.blockId;
      }
    }
    if (!currentBlockId)
      return;
    const startIndex = sortedElements.findIndex((item) => item.blockId === startBlockId);
    const endIndex = sortedElements.findIndex((item) => item.blockId === currentBlockId);
    if (startIndex === -1 || endIndex === -1)
      return;
    const minIndex = Math.min(startIndex, endIndex);
    const maxIndex = Math.max(startIndex, endIndex);
    const newSelection = /* @__PURE__ */ new Set();
    for (let i = minIndex; i <= maxIndex; i++) {
      newSelection.add(sortedElements[i].blockId);
    }
    this.selectedBlocks = newSelection;
    this.updateSelectionDisplay();
    this.onSelectionChange(Array.from(this.selectedBlocks));
  }
  /**
   * 根据选择框更新选中的节点（保留原方法作为备用）
   */
  updateSelectionFromBox(x, y, width, height) {
    const selectionRect = { left: x, top: y, right: x + width, bottom: y + height };
    const newSelection = /* @__PURE__ */ new Set();
    const blockElements = this.container.querySelectorAll("[data-block-id]");
    blockElements.forEach((element) => {
      const rect = element.getBoundingClientRect();
      if (this.isRectIntersecting(rect, selectionRect)) {
        const blockId = element.dataset.blockId;
        if (blockId) {
          newSelection.add(blockId);
        }
      }
    });
    this.selectedBlocks = newSelection;
    this.updateSelectionDisplay();
    this.onSelectionChange(Array.from(this.selectedBlocks));
  }
  /**
   * 检查两个矩形是否相交
   */
  isRectIntersecting(rect, selectionRect) {
    return !(rect.right < selectionRect.left || rect.left > selectionRect.right || rect.bottom < selectionRect.top || rect.top > selectionRect.bottom);
  }
  /**
   * 切换单个节点的选择状态
   */
  toggleBlockSelection(blockId) {
    if (this.selectedBlocks.has(blockId)) {
      this.selectedBlocks.delete(blockId);
    } else {
      this.selectedBlocks.add(blockId);
    }
    this.updateSelectionDisplay();
    this.onSelectionChange(Array.from(this.selectedBlocks));
  }
  /**
   * 更新选择状态的视觉显示
   */
  updateSelectionDisplay() {
    const allElements = this.container.querySelectorAll(".workflowy-item");
    allElements.forEach((element) => {
      element.classList.remove("workflowy-selected");
    });
    this.selectedBlocks.forEach((blockId) => {
      const element = this.container.querySelector(`[data-block-id="${blockId}"]`);
      if (element) {
        element.classList.add("workflowy-selected");
      }
    });
    this.updateSelectionCounter();
  }
  /**
   * 处理容器点击事件
   */
  handleContainerClick(e) {
    if (this.isSelecting || this.justFinishedSelecting) {
      return;
    }
    const target = e.target;
    if (!target.closest("[data-block-id]")) {
      this.clearSelection();
    }
  }
  /**
   * 处理键盘事件
   */
  handleKeyDown(e) {
    if (this.selectedBlocks.size === 0) {
      return;
    }
    const activeElement = document.activeElement;
    if (activeElement && activeElement.classList.contains("workflowy-search")) {
      return;
    }
    switch (e.key) {
      case "Delete":
      case "Backspace":
        this.deleteSelectedBlocks();
        e.preventDefault();
        e.stopImmediatePropagation();
        break;
      case "Escape":
        this.clearSelection();
        e.preventDefault();
        e.stopImmediatePropagation();
        break;
      case "Tab":
        if (e.shiftKey) {
          this.outdentSelectedBlocks();
        } else {
          this.indentSelectedBlocks();
        }
        e.preventDefault();
        e.stopImmediatePropagation();
        break;
      case "a":
        if (e.ctrlKey || e.metaKey) {
          this.selectAll();
          e.preventDefault();
          e.stopImmediatePropagation();
        }
        break;
    }
  }
  /**
   * 删除选中的节点
   */
  deleteSelectedBlocks() {
    if (this.selectedBlocks.size === 0) {
      return;
    }
    const allBlocks = getAllBlocks(this.editor.getState().blocks);
    const selectedBlocksData = allBlocks.filter((block) => this.selectedBlocks.has(block.id));
    selectedBlocksData.sort((a, b) => b.level - a.level);
    selectedBlocksData.forEach((block) => {
      this.editor.deleteBlock(block.id);
    });
    this.clearSelection();
    this.onRender();
  }
  /**
   * 缩进选中的节点
   */
  indentSelectedBlocks() {
    var _a;
    if (this.selectedBlocks.size === 0) {
      return;
    }
    const allBlocks = getAllBlocks(this.editor.getState().blocks);
    const selectedBlocksData = allBlocks.filter((block) => this.selectedBlocks.has(block.id));
    selectedBlocksData.sort((a, b) => {
      const aIndex = allBlocks.indexOf(a);
      const bIndex = allBlocks.indexOf(b);
      return aIndex - bIndex;
    });
    const firstBlockId = (_a = selectedBlocksData[0]) == null ? void 0 : _a.id;
    selectedBlocksData.forEach((block) => {
      this.editor.indentBlock(block.id);
    });
    this.onRender();
    if (firstBlockId) {
      setTimeout(() => {
        this.focusBlock(firstBlockId);
      }, 50);
    }
  }
  /**
   * 取消缩进选中的节点
   */
  outdentSelectedBlocks() {
    var _a;
    if (this.selectedBlocks.size === 0) {
      return;
    }
    const allBlocks = getAllBlocks(this.editor.getState().blocks);
    const selectedBlocksData = allBlocks.filter((block) => this.selectedBlocks.has(block.id));
    selectedBlocksData.sort((a, b) => {
      const aIndex = allBlocks.indexOf(a);
      const bIndex = allBlocks.indexOf(b);
      return aIndex - bIndex;
    });
    const firstBlockId = (_a = selectedBlocksData[0]) == null ? void 0 : _a.id;
    selectedBlocksData.forEach((block) => {
      this.editor.outdentBlock(block.id);
    });
    this.onRender();
    if (firstBlockId) {
      setTimeout(() => {
        this.focusBlock(firstBlockId);
      }, 50);
    }
  }
  /**
   * 聚焦块（支持源码模式和 Live Preview 模式）
   */
  focusBlock(blockId) {
    const blockElement = this.container.querySelector(`[data-block-id="${blockId}"]`);
    if (!blockElement)
      return;
    const displayElement = blockElement.querySelector(".workflowy-content-display");
    if (displayElement) {
      displayElement.click();
    } else {
      const contentElement = blockElement.querySelector(".workflowy-content");
      if (contentElement) {
        contentElement.focus();
      }
    }
  }
  /**
   * 选择所有节点
   */
  selectAll() {
    const allBlocks = getAllBlocks(this.editor.getState().blocks);
    this.selectedBlocks = new Set(allBlocks.map((block) => block.id));
    this.updateSelectionDisplay();
    this.onSelectionChange(Array.from(this.selectedBlocks));
  }
  /**
   * 清除所有选择
   */
  clearSelection() {
    this.selectedBlocks.clear();
    this.updateSelectionDisplay();
    this.onSelectionChange([]);
  }
  /**
   * 获取选中的节点ID列表
   */
  getSelectedBlocks() {
    return Array.from(this.selectedBlocks);
  }
  /**
   * 检查节点是否被选中
   */
  isBlockSelected(blockId) {
    return this.selectedBlocks.has(blockId);
  }
  /**
   * 设置选中的节点
   */
  setSelectedBlocks(blockIds) {
    this.selectedBlocks = new Set(blockIds);
    this.updateSelectionDisplay();
    this.onSelectionChange(Array.from(this.selectedBlocks));
  }
  /**
   * 获取选中节点的数据
   */
  getSelectedBlocksData() {
    const allBlocks = getAllBlocks(this.editor.getState().blocks);
    return allBlocks.filter((block) => this.selectedBlocks.has(block.id));
  }
  /**
   * 开始拖拽选中的节点
   */
  startDragSelectedBlocks(e) {
    if (this.selectedBlocks.size === 0) {
      return;
    }
    if (e.dataTransfer) {
      e.dataTransfer.setData("text/plain", JSON.stringify({
        type: "workflowy-multi-blocks",
        blockIds: Array.from(this.selectedBlocks)
      }));
      e.dataTransfer.effectAllowed = "move";
    }
  }
  /**
   * 处理多选节点的拖拽放置
   */
  handleDropSelectedBlocks(dragData, targetBlockId, position) {
    if (dragData.type !== "workflowy-multi-blocks") {
      return false;
    }
    const sourceBlockIds = dragData.blockIds;
    const allBlocks = getAllBlocks(this.editor.getState().blocks);
    const targetBlock = allBlocks.find((block) => block.id === targetBlockId);
    if (!targetBlock) {
      return false;
    }
    if (this.wouldCreateCycle(sourceBlockIds, targetBlockId, position)) {
      return false;
    }
    const sourceBlocks = allBlocks.filter((block) => sourceBlockIds.includes(block.id));
    sourceBlocks.sort((a, b) => b.level - a.level);
    sourceBlocks.forEach((block) => {
      this.editor.moveBlock(block.id, targetBlockId, position);
    });
    this.onRender();
    return true;
  }
  /**
   * 检查移动是否会造成循环引用
   */
  wouldCreateCycle(sourceBlockIds, targetBlockId, position) {
    if (position === "child") {
      return sourceBlockIds.some((sourceId) => {
        return this.isAncestor(sourceId, targetBlockId);
      });
    }
    const allBlocksForCycle = getAllBlocks(this.editor.getState().blocks);
    const targetBlockForCycle = allBlocksForCycle.find((block) => block.id === targetBlockId);
    if (!targetBlockForCycle) {
      return false;
    }
    const parentId = this.findParentId(targetBlockId);
    if (!parentId) {
      return false;
    }
    return sourceBlockIds.some((sourceId) => {
      return this.isAncestor(sourceId, parentId);
    });
  }
  /**
   * 检查是否是祖先节点
   */
  isAncestor(ancestorId, descendantId) {
    const allBlocks = getAllBlocks(this.editor.getState().blocks);
    const descendant = allBlocks.find((block) => block.id === descendantId);
    if (!descendant) {
      return false;
    }
    const parentId = this.findParentId(descendantId);
    if (!parentId) {
      return false;
    }
    if (parentId === ancestorId) {
      return true;
    }
    return this.isAncestor(ancestorId, parentId);
  }
  /**
   * 查找父节点ID
   */
  findParentId(blockId) {
    const allBlocks = getAllBlocks(this.editor.getState().blocks);
    for (const block of allBlocks) {
      if (block.children.some((child) => child.id === blockId)) {
        return block.id;
      }
    }
    return null;
  }
  /**
   * 销毁管理器
   */
  destroy() {
    if (this.updateThrottleTimer !== null) {
      window.clearTimeout(this.updateThrottleTimer);
      this.updateThrottleTimer = null;
    }
    if (this.boundKeyDownHandler) {
      document.removeEventListener("keydown", this.boundKeyDownHandler, true);
    }
    if (this.selectionBox) {
      document.body.removeChild(this.selectionBox);
      this.selectionBox = null;
    }
    if (this.selectionCounter) {
      document.body.removeChild(this.selectionCounter);
      this.selectionCounter = null;
    }
    this.clearSelection();
  }
};

// src/features/zoom.ts
var ZoomManager = class {
  constructor(editor, getDocumentTitle) {
    this.editor = editor;
    this.getDocumentTitle = getDocumentTitle;
    this.zoomedBlockId = null;
  }
  /**
   * 设置缩放变化回调
   */
  setOnZoomChange(callback) {
    this.onZoomChange = callback;
  }
  /**
   * 获取当前缩放的块ID
   */
  getZoomedBlockId() {
    return this.zoomedBlockId;
  }
  /**
   * 缩放到指定块
   */
  zoomIn(blockId) {
    const block = findBlockById(this.editor.getState().blocks, blockId);
    if (!block) {
      console.warn("[ZoomManager] Block not found:", blockId);
      return false;
    }
    this.zoomedBlockId = blockId;
    if (this.onZoomChange) {
      this.onZoomChange(blockId);
    }
    return true;
  }
  /**
   * 缩放退出（显示所有内容）
   */
  zoomOut() {
    this.zoomedBlockId = null;
    if (this.onZoomChange) {
      this.onZoomChange(null);
    }
  }
  /**
   * 检查某个块是否应该显示
   * @param blockId 要检查的块ID
   * @param allBlocks 所有块的扁平列表
   */
  shouldShowBlock(blockId, allBlocks) {
    if (!this.zoomedBlockId) {
      return true;
    }
    const currentBlock = allBlocks.find((b) => b.id === blockId);
    const zoomedBlock = allBlocks.find((b) => b.id === this.zoomedBlockId);
    if (!currentBlock || !zoomedBlock) {
      return false;
    }
    if (blockId === this.zoomedBlockId) {
      return true;
    }
    return this.isDescendant(zoomedBlock, currentBlock, this.editor.getState().blocks);
  }
  /**
   * 检查一个块是否是另一个块的后代
   */
  isDescendant(ancestor, descendant, blocks) {
    function checkChildren(children) {
      for (const child of children) {
        if (child.id === descendant.id) {
          return true;
        }
        if (checkChildren(child.children)) {
          return true;
        }
      }
      return false;
    }
    return checkChildren(ancestor.children);
  }
  /**
   * 收集面包屑导航
   * @param blockId 当前聚焦的块ID（如果为null，使用缩放的块ID）
   */
  collectBreadcrumbs(blockId) {
    const targetBlockId = blockId || this.zoomedBlockId;
    if (!targetBlockId) {
      return [{
        title: this.getDocumentTitle(),
        blockId: null
      }];
    }
    const allBlocks = getAllBlocks(this.editor.getState().blocks);
    const targetBlock = allBlocks.find((b) => b.id === targetBlockId);
    if (!targetBlock) {
      return [{
        title: this.getDocumentTitle(),
        blockId: null
      }];
    }
    const breadcrumbs = [
      {
        title: this.getDocumentTitle(),
        blockId: null
      }
    ];
    const path = this.findPathToBlock(targetBlockId, this.editor.getState().blocks);
    for (const block of path) {
      breadcrumbs.push({
        title: this.cleanTitle(block.content),
        blockId: block.id
      });
    }
    return breadcrumbs;
  }
  /**
   * 找到从根到指定块的路径
   */
  findPathToBlock(blockId, blocks, path = []) {
    for (const block of blocks) {
      if (block.id === blockId) {
        return [...path, block];
      }
      if (block.children.length > 0) {
        const childPath = this.findPathToBlock(blockId, block.children, [...path, block]);
        if (childPath.length > 0) {
          return childPath;
        }
      }
    }
    return [];
  }
  /**
   * 清理标题文本（去除标记符号）
   */
  cleanTitle(title) {
    if (!title.trim()) {
      return "(\u7A7A)";
    }
    return title.trim().replace(/^#+(\s)/, "$1").replace(/^([-+*]|\d+\.)(\s)/, "$2").replace(/^\s*\[[ xX]\]\s*/, "").trim() || "(\u7A7A)";
  }
  /**
   * 获取应该显示的块ID列表（用于过滤渲染）
   */
  getVisibleBlockIds() {
    if (!this.zoomedBlockId) {
      return null;
    }
    const allBlocks = getAllBlocks(this.editor.getState().blocks);
    const zoomedBlock = allBlocks.find((b) => b.id === this.zoomedBlockId);
    if (!zoomedBlock) {
      return null;
    }
    const visibleIds = /* @__PURE__ */ new Set();
    visibleIds.add(this.zoomedBlockId);
    function addDescendants(block) {
      for (const child of block.children) {
        visibleIds.add(child.id);
        addDescendants(child);
      }
    }
    addDescendants(zoomedBlock);
    return visibleIds;
  }
  /**
   * 检查是否处于缩放状态
   */
  isZoomed() {
    return this.zoomedBlockId !== null;
  }
};

// src/features/theme-manager.ts
var THEMES = [
  {
    id: "default",
    name: "\u9ED8\u8BA4",
    description: "\u8DDF\u968F Obsidian \u4E3B\u9898"
  },
  {
    id: "classic-white",
    name: "\u7ECF\u5178\u767D",
    description: "\u767D\u8272\u80CC\u666F\uFF0C\u6DF1\u7070\u6587\u5B57"
  },
  {
    id: "dark-orange-green",
    name: "\u6697\u591C\u6A59\u7EFF",
    description: "\u9ED1\u8272\u80CC\u666F\uFF0C\u6A59\u7EFF\u914D\u8272"
  },
  {
    id: "warm-beige",
    name: "\u7C73\u767D\u7070",
    description: "\u7C73\u767D\u80CC\u666F\uFF0C\u6E29\u6696\u8212\u9002"
  },
  {
    id: "soft-purple",
    name: "\u6DE1\u7D2B",
    description: "\u6DE1\u7D2B\u80CC\u666F\uFF0C\u4F18\u96C5\u67D4\u548C"
  },
  {
    id: "deep-blue",
    name: "\u6DF1\u84DD",
    description: "\u6DF1\u84DD\u80CC\u666F\uFF0C\u4E13\u6CE8\u6C89\u7A33"
  },
  {
    id: "dark-gray",
    name: "\u6DF1\u7070",
    description: "\u6DF1\u7070\u80CC\u666F\uFF0C\u7B80\u7EA6\u73B0\u4EE3"
  },
  {
    id: "forest-green",
    name: "\u68EE\u6797\u7EFF",
    description: "\u62A4\u773C\u7EFF\u8272\uFF0C\u81EA\u7136\u6E05\u65B0"
  },
  {
    id: "ocean-blue",
    name: "\u6D77\u6D0B\u84DD",
    description: "\u84DD\u8272\u80CC\u666F\uFF0C\u6E05\u723D\u5B81\u9759"
  },
  {
    id: "sunset-orange",
    name: "\u65E5\u843D\u6A59",
    description: "\u6A59\u8272\u8C03\uFF0C\u6E29\u6696\u6D3B\u529B"
  },
  {
    id: "cherry-pink",
    name: "\u6A31\u82B1\u7C89",
    description: "\u7C89\u8272\u80CC\u666F\uFF0C\u67D4\u548C\u6D6A\u6F2B"
  },
  {
    id: "midnight-black",
    name: "\u5348\u591C\u9ED1",
    description: "\u7EAF\u9ED1\u80CC\u666F\uFF0C\u6781\u81F4\u6697\u8272"
  },
  {
    id: "element-dark",
    name: "Space",
    description: "\u6DF1\u7070\u80CC\u666F\uFF0C\u9EC4\u8272\u9AD8\u4EAE"
  },
  {
    id: "matrix-green",
    name: "Hacker",
    description: "\u9ED1\u5BA2\u98CE\u683C\uFF0C\u8367\u5149\u7EFF"
  }
];
var ThemeManager = class {
  constructor(defaultTheme = "default") {
    this.container = null;
    this.currentTheme = defaultTheme;
  }
  /**
   * 设置主题容器
   */
  setContainer(container) {
    this.container = container;
    this.applyTheme(this.currentTheme);
  }
  /**
   * 设置主题变化回调
   */
  setOnThemeChange(callback) {
    this.onThemeChange = callback;
  }
  /**
   * 获取当前主题
   */
  getCurrentTheme() {
    return this.currentTheme;
  }
  /**
   * 应用主题
   */
  applyTheme(themeId) {
    if (!this.container) {
      console.warn("[ThemeManager] Container not set");
      return;
    }
    THEMES.forEach((theme) => {
      var _a;
      (_a = this.container) == null ? void 0 : _a.classList.remove(`workflowy-theme-${theme.id}`);
    });
    this.container.classList.add(`workflowy-theme-${themeId}`);
    this.currentTheme = themeId;
    if (this.onThemeChange) {
      this.onThemeChange(themeId);
    }
  }
  /**
   * 切换到下一个主题
   */
  nextTheme() {
    const currentIndex = THEMES.findIndex((t) => t.id === this.currentTheme);
    const nextIndex = (currentIndex + 1) % THEMES.length;
    this.applyTheme(THEMES[nextIndex].id);
  }
  /**
   * 获取所有主题
   */
  getThemes() {
    return THEMES;
  }
};

// src/ui/navigation-header.ts
var NavigationHeader = class {
  constructor() {
    this.headerElement = null;
    this.searchInput = null;
    this.searchClearButton = null;
    this.searchContainer = null;
    this.breadcrumbsContainer = null;
    this.themeButton = null;
    this.themeMenu = null;
  }
  /**
   * 创建导航头部DOM
   */
  create(container) {
    if (this.headerElement) {
      this.headerElement.remove();
    }
    this.headerElement = container.createDiv("workflowy-navigation-header");
    this.breadcrumbsContainer = this.headerElement.createDiv("workflowy-breadcrumbs");
    this.searchContainer = this.headerElement.createDiv("workflowy-search-container");
    this.searchInput = this.searchContainer.createEl("input", {
      type: "text",
      placeholder: "\u641C\u7D22...",
      cls: "workflowy-search"
    });
    this.searchClearButton = this.searchContainer.createDiv("workflowy-search-clear");
    this.searchClearButton.innerHTML = `
            <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
        `;
    this.searchClearButton.style.display = "none";
    this.searchInput.oninput = (e) => {
      const query = e.target.value;
      if (this.searchClearButton) {
        this.searchClearButton.style.display = query ? "flex" : "none";
      }
      if (this.onSearch) {
        this.onSearch(query);
      }
    };
    this.searchInput.addEventListener("focus", () => {
      document.querySelectorAll(".workflowy-item.focused").forEach((el) => {
        el.classList.remove("focused");
      });
    });
    this.searchClearButton.addEventListener("click", () => {
      if (this.searchInput) {
        this.searchInput.value = "";
        this.searchClearButton.style.display = "none";
        if (this.onSearch) {
          this.onSearch("");
        }
        this.searchInput.focus();
      }
    });
    this.createThemeButton();
  }
  /**
   * 创建主题切换按钮
   */
  createThemeButton() {
    if (!this.headerElement)
      return;
    this.themeButton = this.headerElement.createDiv("workflowy-theme-button");
    this.themeButton.innerHTML = `
            <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="3" width="7" height="7" rx="1"/>
                <rect x="14" y="3" width="7" height="7" rx="1"/>
                <rect x="14" y="14" width="7" height="7" rx="1"/>
                <rect x="3" y="14" width="7" height="7" rx="1"/>
            </svg>
        `;
    this.themeButton.setAttribute("aria-label", "\u5207\u6362\u4E3B\u9898");
    this.themeButton.setAttribute("title", "\u5207\u6362\u4E3B\u9898");
    this.themeMenu = this.headerElement.createDiv("workflowy-theme-menu");
    this.themeMenu.style.display = "none";
    this.renderThemeOptions();
    this.themeButton.addEventListener("click", (e) => {
      e.stopPropagation();
      this.toggleThemeMenu();
    });
    document.addEventListener("click", (e) => {
      var _a;
      if (this.themeMenu && this.themeMenu.style.display !== "none" && !this.themeMenu.contains(e.target) && !((_a = this.themeButton) == null ? void 0 : _a.contains(e.target))) {
        this.hideThemeMenu();
      }
    });
  }
  /**
   * 渲染主题选项
   */
  renderThemeOptions() {
    if (!this.themeMenu)
      return;
    this.themeMenu.empty();
    THEMES.forEach((theme) => {
      const option = this.themeMenu.createDiv("workflowy-theme-option");
      option.setAttribute("data-theme-id", theme.id);
      const preview = option.createDiv("workflowy-theme-preview");
      preview.classList.add(`workflowy-theme-${theme.id}`);
      preview.innerHTML = `
                <div class="theme-preview-content">
                    <div class="theme-preview-bullet"></div>
                    <div class="theme-preview-text">${theme.name}</div>
                </div>
            `;
      const info = option.createDiv("workflowy-theme-info");
      const name = info.createDiv("workflowy-theme-name");
      name.textContent = theme.name;
      const desc = info.createDiv("workflowy-theme-desc");
      desc.textContent = theme.description;
      if (this.themeManager && this.themeManager.getCurrentTheme() === theme.id) {
        option.classList.add("active");
      }
      option.addEventListener("click", () => {
        this.selectTheme(theme.id);
      });
    });
  }
  /**
   * 切换主题菜单显示/隐藏
   */
  toggleThemeMenu() {
    if (!this.themeMenu) {
      console.warn("[NavigationHeader] Theme menu not found");
      return;
    }
    if (this.themeMenu.style.display === "none") {
      this.showThemeMenu();
    } else {
      this.hideThemeMenu();
    }
  }
  /**
   * 显示主题菜单
   */
  showThemeMenu() {
    if (!this.themeMenu)
      return;
    this.themeMenu.style.display = "block";
  }
  /**
   * 隐藏主题菜单
   */
  hideThemeMenu() {
    if (!this.themeMenu)
      return;
    this.themeMenu.style.display = "none";
  }
  /**
   * 选择主题
   */
  selectTheme(themeId) {
    var _a;
    if (this.themeManager) {
      this.themeManager.applyTheme(themeId);
      (_a = this.themeMenu) == null ? void 0 : _a.querySelectorAll(".workflowy-theme-option").forEach((option) => {
        if (option.getAttribute("data-theme-id") === themeId) {
          option.classList.add("active");
        } else {
          option.classList.remove("active");
        }
      });
    }
    this.hideThemeMenu();
  }
  /**
   * 设置主题管理器
   */
  setThemeManager(themeManager) {
    this.themeManager = themeManager;
    if (this.themeMenu) {
      this.renderThemeOptions();
    }
  }
  /**
   * 更新面包屑导航
   */
  updateBreadcrumbs(breadcrumbs) {
    if (!this.breadcrumbsContainer) {
      console.warn("[NavigationHeader] Breadcrumbs container not initialized");
      return;
    }
    this.breadcrumbsContainer.empty();
    for (let i = 0; i < breadcrumbs.length; i++) {
      if (i > 0) {
        const delimiter = this.breadcrumbsContainer.createSpan("workflowy-breadcrumb-delimiter");
        delimiter.textContent = "\u203A";
      }
      const breadcrumb = breadcrumbs[i];
      const item = this.breadcrumbsContainer.createEl("a", {
        cls: "workflowy-breadcrumb-item",
        attr: {
          "data-block-id": breadcrumb.blockId || "root"
        }
      });
      item.textContent = breadcrumb.title;
      item.addEventListener("click", (e) => {
        e.preventDefault();
        if (this.onBreadcrumbClick) {
          this.onBreadcrumbClick(breadcrumb.blockId);
        }
      });
      if (i === breadcrumbs.length - 1) {
        item.classList.add("current");
      }
    }
  }
  /**
   * 显示头部
   */
  show() {
    if (this.headerElement) {
      this.headerElement.style.display = "";
    }
  }
  /**
   * 隐藏头部
   */
  hide() {
    if (this.headerElement) {
      this.headerElement.style.display = "none";
    }
  }
  /**
   * 显示搜索框
   */
  showSearch() {
    if (this.searchContainer) {
      this.searchContainer.style.display = "";
    }
    if (this.headerElement) {
      this.headerElement.classList.remove("zoom-mode");
    }
  }
  /**
   * 隐藏搜索框
   */
  hideSearch() {
    if (this.searchContainer) {
      this.searchContainer.style.display = "none";
    }
    if (this.headerElement) {
      this.headerElement.classList.add("zoom-mode");
    }
  }
  /**
   * 设置面包屑点击回调
   */
  setOnBreadcrumbClick(callback) {
    this.onBreadcrumbClick = callback;
  }
  /**
   * 设置搜索回调
   */
  setOnSearch(callback) {
    this.onSearch = callback;
  }
  /**
   * 获取搜索框的值
   */
  getSearchQuery() {
    var _a;
    return ((_a = this.searchInput) == null ? void 0 : _a.value) || "";
  }
  /**
   * 清空搜索框
   */
  clearSearch() {
    if (this.searchInput) {
      this.searchInput.value = "";
      if (this.searchClearButton) {
        this.searchClearButton.style.display = "none";
      }
    }
  }
  /**
   * 设置搜索框的值
   */
  setSearchQuery(query) {
    if (this.searchInput) {
      this.searchInput.value = query;
      if (this.searchClearButton) {
        this.searchClearButton.style.display = query ? "flex" : "none";
      }
    }
  }
  /**
   * 销毁头部
   */
  destroy() {
    if (this.headerElement) {
      this.headerElement.remove();
      this.headerElement = null;
    }
    this.searchInput = null;
    this.breadcrumbsContainer = null;
  }
};

// src/workflowy-view.ts
var WorkflowyView = class extends import_obsidian4.FileView {
  constructor(leaf, plugin) {
    var _a, _b;
    super(leaf);
    this.blockElements = /* @__PURE__ */ new Map();
    this.containerSelector = null;
    this.verticalLinesManager = null;
    this.multiSelectionManager = null;
    this.zoomManager = null;
    this.navigationHeader = null;
    this.themeManager = null;
    /**
     * FileView 必需属性：是否允许没有文件
     */
    this.allowNoFile = false;
    this.plugin = plugin;
    this.editor = new BlockEditor();
    this.zoomManager = new ZoomManager(
      this.editor,
      () => this.getDocumentTitle()
    );
    this.zoomManager.setOnZoomChange((zoomedBlockId) => {
      this.handleZoomChange(zoomedBlockId);
    });
    const savedTheme = ((_b = (_a = this.plugin.settings) == null ? void 0 : _a.ui) == null ? void 0 : _b.theme) || "default";
    this.themeManager = new ThemeManager(savedTheme);
    this.themeManager.setOnThemeChange((themeId) => {
      if (this.plugin.settings) {
        this.plugin.settings.ui.theme = themeId;
        this.plugin.saveSettings();
      }
    });
  }
  getViewType() {
    return WORKFLOWY_VIEW_TYPE;
  }
  getDisplayText() {
    var _a;
    return ((_a = this.file) == null ? void 0 : _a.basename) || "Workflowy View";
  }
  getIcon() {
    return "list-tree";
  }
  async onOpen() {
    var _a;
    this.container = this.contentEl;
    this.container.empty();
    this.container.addClass("workflowy-container");
    const uniqueId = `workflowy-container-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
    this.container.setAttribute("id", uniqueId);
    this.containerSelector = `#${uniqueId}`;
    if (this.themeManager) {
      this.themeManager.setContainer(this.container);
    }
    EventDelegator.getInstance().registerEvent(
      "keydown",
      this.containerSelector,
      (ev) => {
        const e = ev;
        const hasMultiSelection = this.multiSelectionManager && this.multiSelectionManager.getSelectedBlocks().length > 0;
        const isMultiSelectionKey = hasMultiSelection && (e.key === "Delete" || e.key === "Backspace" || e.key === "Escape" || e.key === "Tab" || // TAB 键也是多选相关的
        e.key === "a" && (e.ctrlKey || e.metaKey));
        if (isMultiSelectionKey) {
          return;
        }
        const target = e.target;
        const isMod = e.ctrlKey || e.metaKey;
        const isMarkdownShortcut = isMod && (e.key === "b" || // 加粗
        e.key === "i" || // 斜体
        e.key === "k" || // 链接
        e.shiftKey && e.key === "H");
        const isInLivePreviewEditor = target.classList.contains("workflowy-content-editor") || target.closest(".workflowy-content-editor");
        if (isMarkdownShortcut && isInLivePreviewEditor) {
          return;
        }
        e.stopImmediatePropagation();
        let contentEl = target.closest(".workflowy-content");
        if (!contentEl && document.activeElement)
          contentEl = document.activeElement.closest(".workflowy-content");
        const hostItemEl = contentEl == null ? void 0 : contentEl.closest(".workflowy-item");
        let blockId = (contentEl == null ? void 0 : contentEl.getAttribute("data-block-id")) || (hostItemEl == null ? void 0 : hostItemEl.getAttribute("data-block-id")) || null;
        if (!blockId && typeof this.getFocusedBlockId === "function") {
          const focusedId = this.getFocusedBlockId();
          if (focusedId) {
            blockId = focusedId;
          }
        }
        if (!blockId) {
          console.warn("[WorkflowyView] No blockId for keydown, skipping dispatch");
          return;
        }
        const item = this.blockElements.get(blockId);
        if (item && typeof item.onKeyDownDelegated === "function") {
          item.onKeyDownDelegated(e);
        } else {
          console.warn("[WorkflowyView] No OutlineItem found for blockId:", blockId);
        }
      },
      { capture: true }
      // 明确指定捕获阶段
    );
    this.createNavigationHeader();
    this.container.createDiv("workflowy-editor");
    if (!this.file) {
      const state = this.leaf.getViewState();
      if (((_a = state.state) == null ? void 0 : _a.file) && typeof state.state.file === "string") {
        await this.loadFile(state.state.file);
      }
    }
    this.renderBlocks();
  }
  async onClose() {
    this.saveAllEditingContent();
    if (this.file) {
      await this.saveToFile();
    }
    if (this.containerSelector) {
      EventDelegator.getInstance().unregisterEvent("keydown", this.containerSelector);
      this.containerSelector = null;
    }
    if (this.navigationHeader) {
      this.navigationHeader.destroy();
      this.navigationHeader = null;
    }
    if (this.verticalLinesManager) {
      this.verticalLinesManager.destroy();
      this.verticalLinesManager = null;
    }
    if (this.multiSelectionManager) {
      this.multiSelectionManager.destroy();
      this.multiSelectionManager = null;
    }
    this.zoomManager = null;
    this.blockElements.clear();
  }
  async setState(state, result) {
    var _a;
    if (result && typeof result === "object") {
      if ((state == null ? void 0 : state.file) && state.file !== ((_a = this.file) == null ? void 0 : _a.path)) {
        result.history = true;
      }
    }
    return super.setState(state, result);
  }
  getState() {
    var _a;
    return {
      file: (_a = this.file) == null ? void 0 : _a.path
    };
  }
  // 重写菜单方法，添加切换选项
  onPaneMenu(menu, source) {
    super.onPaneMenu(menu, source);
    if (source === "more-options" && this.file) {
      menu.addItem((item) => {
        item.setTitle("\u6253\u5F00\u4E3AMarkdown").setIcon("edit").onClick(() => {
          this.plugin.openAsMarkdown(this.file);
        });
      });
    }
  }
  /**
   * 创建导航头部（面包屑+搜索框）
   */
  createNavigationHeader() {
    this.navigationHeader = new NavigationHeader();
    this.navigationHeader.create(this.container);
    if (this.themeManager) {
      this.navigationHeader.setThemeManager(this.themeManager);
    }
    this.navigationHeader.setOnBreadcrumbClick((blockId) => {
      this.handleBreadcrumbClick(blockId);
    });
    this.navigationHeader.setOnSearch((query) => {
      this.handleSearch(query);
    });
    this.updateNavigationHeader();
  }
  /**
   * 获取文档标题
   */
  getDocumentTitle() {
    var _a;
    return ((_a = this.file) == null ? void 0 : _a.basename) || "Untitled";
  }
  /**
   * 更新导航头部
   */
  updateNavigationHeader() {
    if (!this.navigationHeader || !this.zoomManager) {
      return;
    }
    const breadcrumbs = this.zoomManager.collectBreadcrumbs();
    this.navigationHeader.updateBreadcrumbs(breadcrumbs);
    if (this.zoomManager.isZoomed()) {
      this.navigationHeader.hideSearch();
      this.navigationHeader.show();
    } else {
      this.navigationHeader.showSearch();
      this.navigationHeader.show();
    }
  }
  /**
   * 处理面包屑点击
   */
  handleBreadcrumbClick(blockId) {
    if (!this.zoomManager) {
      return;
    }
    if (blockId === null) {
      this.zoomManager.zoomOut();
    } else {
      this.zoomManager.zoomIn(blockId);
    }
  }
  /**
   * 处理Zoom状态变化
   */
  handleZoomChange(zoomedBlockId) {
    this.updateNavigationHeader();
    this.renderBlocks();
    if (zoomedBlockId) {
      setTimeout(() => {
        const item = this.blockElements.get(zoomedBlockId);
        if (item) {
          item.focus();
          const element = item.getElement();
          const contentEl = element.querySelector(".workflowy-content-editor, .workflowy-content");
          if (contentEl) {
            if (contentEl instanceof HTMLTextAreaElement) {
              contentEl.setSelectionRange(contentEl.value.length, contentEl.value.length);
            } else {
              const selection = window.getSelection();
              if (selection) {
                const range = document.createRange();
                try {
                  if (contentEl.childNodes.length > 0) {
                    range.selectNodeContents(contentEl);
                    range.collapse(false);
                  } else {
                    range.setStart(contentEl, 0);
                    range.setEnd(contentEl, 0);
                  }
                  selection.removeAllRanges();
                  selection.addRange(range);
                } catch (error) {
                  console.error("[WorkflowyView] Error setting cursor to end:", error);
                }
              }
            }
          }
        }
      }, 100);
    }
  }
  async loadFile(filePath) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian4.TFile) {
      this.file = file;
      const content = await this.app.vault.read(file);
      this.editor.loadFromMarkdown(content);
      this.renderBlocks();
      this.updateNavigationHeader();
    } else {
      console.error("[WorkflowyView] File not found or not a TFile:", filePath);
    }
  }
  async saveToFile() {
    if (!this.file)
      return;
    const markdown = this.editor.toMarkdown();
    await this.app.vault.modify(this.file, markdown);
  }
  async renderBlocks() {
    var _a, _b;
    const editorContainer = this.container.querySelector(".workflowy-editor");
    if (!editorContainer) {
      console.error("[WorkflowyView] Editor container not found!");
      return;
    }
    editorContainer.empty();
    this.blockElements.clear();
    const state = this.editor.getState();
    const renderPromises = [];
    if (this.zoomManager && this.zoomManager.isZoomed()) {
      const zoomedBlockId = this.zoomManager.getZoomedBlockId();
      if (zoomedBlockId) {
        const allBlocks = getAllBlocks(state.blocks);
        const zoomedBlock = allBlocks.find((b) => b.id === zoomedBlockId);
        if (zoomedBlock) {
          await this.renderZoomedBlock(zoomedBlock, editorContainer);
        } else {
          console.warn("[WorkflowyView] Zoomed block not found, exiting zoom");
          this.zoomManager.zoomOut();
          const promises = this.renderBlockList(state.blocks, editorContainer);
          renderPromises.push(...promises);
        }
      } else {
        const promises = this.renderBlockList(state.blocks, editorContainer);
        renderPromises.push(...promises);
      }
    } else {
      const promises = this.renderBlockList(state.blocks, editorContainer);
      renderPromises.push(...promises);
    }
    await Promise.all(renderPromises);
    if (state.blocks.length === 0 && !((_a = this.zoomManager) == null ? void 0 : _a.isZoomed())) {
      this.editor.createNewBlock();
      this.renderBlocks();
      return;
    }
    if ((_b = this.zoomManager) == null ? void 0 : _b.isZoomed()) {
      const zoomedBlockId = this.zoomManager.getZoomedBlockId();
      if (zoomedBlockId && this.blockElements.size === 0) {
        console.warn("[WorkflowyView] Zoom block has no content, but should still be visible");
      }
    }
    requestAnimationFrame(() => {
      this.initializeVerticalLines(editorContainer);
      this.initializeMultiSelection(editorContainer);
    });
  }
  /**
   * 初始化垂直线管理器
   */
  initializeVerticalLines(editorContainer) {
    if (this.verticalLinesManager) {
      this.verticalLinesManager.destroy();
    }
    this.verticalLinesManager = new VerticalLinesManager(
      editorContainer,
      this.editor,
      (blockId) => this.handleVerticalLineClick(blockId)
    );
    requestAnimationFrame(() => {
      if (this.verticalLinesManager) {
        this.verticalLinesManager.update();
      }
    });
  }
  /**
   * 初始化多选管理器
   */
  initializeMultiSelection(editorContainer) {
    let previousSelection = [];
    if (this.multiSelectionManager) {
      previousSelection = this.multiSelectionManager.getSelectedBlocks();
      this.multiSelectionManager.destroy();
    }
    this.multiSelectionManager = new MultiSelectionManager(
      editorContainer,
      this.editor,
      (selectedIds) => this.handleSelectionChange(selectedIds),
      () => this.renderBlocks()
    );
    if (previousSelection.length > 0) {
      requestAnimationFrame(() => {
        if (this.multiSelectionManager) {
          this.multiSelectionManager.setSelectedBlocks(previousSelection);
        }
      });
    }
  }
  /**
   * 处理选择变化事件
   */
  handleSelectionChange(selectedIds) {
  }
  /**
   * 处理垂直线点击事件
   * 注意：垂直线管理器已经处理了折叠逻辑，这里只需要更新视图
   */
  handleVerticalLineClick(blockId) {
    this.renderBlocks();
    setTimeout(() => {
      const item = this.blockElements.get(blockId);
      if (item) {
        item.focus();
      }
    }, 100);
  }
  /**
   * 处理bullet点击事件（缩放功能）
   */
  handleBulletClick(blockId) {
    if (!this.zoomManager) {
      return;
    }
    if (this.zoomManager.getZoomedBlockId() === blockId) {
      this.zoomManager.zoomOut();
    } else {
      this.zoomManager.zoomIn(blockId);
    }
  }
  renderBlockList(blocks, container, parentCompletedTodo = false) {
    var _a;
    const renderPromises = [];
    for (let i = 0; i < blocks.length; i++) {
      const block = blocks[i];
      try {
        const blockItem = new OutlineItem(
          block,
          this.editor,
          (blockId, content) => this.handleBlockUpdate(blockId, content),
          (blockId) => this.handleBlockFocus(blockId),
          async () => await this.renderBlocks(),
          // 重新渲染回调（异步）
          () => this.multiSelectionManager,
          // 多选管理器获取函数
          (blockId) => this.handleBulletClick(blockId),
          // bullet点击回调（用于zoom）
          () => {
            var _a2;
            return ((_a2 = this.zoomManager) == null ? void 0 : _a2.getZoomedBlockId()) || null;
          },
          // 获取当前zoom的块ID
          this.app,
          // Obsidian App 实例
          ((_a = this.file) == null ? void 0 : _a.path) || "",
          // 文件路径
          this.plugin.settings
          // 插件设置
        );
        const renderPromise = blockItem.waitForRender();
        if (renderPromise) {
          renderPromises.push(renderPromise);
        }
        const element = blockItem.getElement();
        if (parentCompletedTodo) {
          element.classList.add("child-of-completed-todo");
        }
        container.appendChild(element);
        this.blockElements.set(block.id, blockItem);
        if (block.children.length > 0 && !this.editor.isCollapsed(block.id)) {
          const childContainer = container.createDiv("workflowy-children");
          const isCompletedTodo = block.isTodo && block.todoCompleted;
          const childPromises = this.renderBlockList(block.children, childContainer, isCompletedTodo || parentCompletedTodo);
          renderPromises.push(...childPromises);
        }
      } catch (error) {
        console.error("[WorkflowyView] Error rendering block:", error);
        console.error("[WorkflowyView] Block data:", block);
      }
    }
    return renderPromises;
  }
  handleBlockUpdate(blockId, content) {
    this.editor.updateBlockContent(blockId, content);
    if (this.verticalLinesManager) {
      requestAnimationFrame(() => {
        if (this.verticalLinesManager) {
          this.verticalLinesManager.update();
        }
      });
    }
    if (this.file) {
      this.saveToFile();
    }
  }
  /**
   * 渲染缩放后的块（只渲染该块和子块）
   * 缩放后的块显示为第一级（level 0），子块相应调整级别
   */
  async renderZoomedBlock(block, container, parentCompletedTodo = false) {
    var _a;
    try {
      const zoomedBlockCopy = {
        ...block,
        level: 0
      };
      const blockItem = new OutlineItem(
        zoomedBlockCopy,
        this.editor,
        (blockId, content) => this.handleBlockUpdate(blockId, content),
        (blockId) => this.handleBlockFocus(blockId),
        async () => await this.renderBlocks(),
        () => this.multiSelectionManager,
        (blockId) => this.handleBulletClick(blockId),
        () => {
          var _a2;
          return ((_a2 = this.zoomManager) == null ? void 0 : _a2.getZoomedBlockId()) || null;
        },
        // 获取当前zoom的块ID
        this.app,
        // Obsidian App 实例
        ((_a = this.file) == null ? void 0 : _a.path) || "",
        // 文件路径
        this.plugin.settings
        // 插件设置
      );
      const element = blockItem.getElement();
      if (parentCompletedTodo) {
        element.classList.add("child-of-completed-todo");
      }
      container.appendChild(element);
      this.blockElements.set(block.id, blockItem);
      if (block.children.length > 0 && !this.editor.isCollapsed(block.id)) {
        const childContainer = container.createDiv("workflowy-children");
        const isCompletedTodo = block.isTodo && block.todoCompleted;
        const adjustedChildren = this.adjustChildrenLevel(block.children, block.level);
        const childPromises = this.renderBlockList(adjustedChildren, childContainer, isCompletedTodo || parentCompletedTodo);
        await Promise.all(childPromises);
      } else {
        if (block.children.length === 0) {
          const emptyHint = container.createDiv("workflowy-empty-hint");
          emptyHint.textContent = "\u70B9\u51FB\u65B0\u589E\u8282\u70B9";
          emptyHint.style.cssText = `
                        padding-left: 60px;
                        color: var(--text-muted);
                        font-style: italic;
                        cursor: pointer;
                        padding-top: 8px;
                        padding-bottom: 8px;
                    `;
          emptyHint.addEventListener("click", () => {
            const newBlock = this.editor.createChildBlock(block.id);
            this.renderBlocks();
            setTimeout(() => {
              const blockItem2 = this.blockElements.get(newBlock.id);
              if (blockItem2) {
                blockItem2.focus();
              }
            }, 50);
          });
        }
      }
    } catch (error) {
      console.error("[WorkflowyView] Error rendering zoomed block:", error);
    }
  }
  /**
   * 调整子块的level，使其相对于缩放块的原始level
   */
  adjustChildrenLevel(children, baseLevel) {
    return children.map((child) => ({
      ...child,
      level: child.level - baseLevel,
      children: this.adjustChildrenLevel(child.children, baseLevel)
    }));
  }
  handleBlockFocus(blockId) {
    this.editor.focusBlock(blockId);
    this.blockElements.forEach((item, id) => {
      if (id !== blockId) {
        item.blur();
      }
    });
    if (this.zoomManager && this.zoomManager.isZoomed()) {
      this.updateNavigationHeader();
    }
  }
  collapseAll() {
    const allBlocks = getAllBlocks(this.editor.getState().blocks);
    for (const block of allBlocks) {
      if (block.children.length > 0) {
        this.editor.toggleCollapse(block.id);
      }
    }
    this.renderBlocks();
  }
  expandAll() {
    const state = this.editor.getState();
    state.collapsedBlocks.clear();
    this.renderBlocks();
  }
  handleSearch(query) {
    const trimmedQuery = query.trim();
    if (!trimmedQuery) {
      this.clearSearch();
      return;
    }
    const searchMode = this.plugin.settings.search.mode;
    const caseSensitive = this.plugin.settings.search.caseSensitive;
    const autoExpand = this.plugin.settings.search.autoExpandMatches;
    if (searchMode === "highlight") {
      this.handleHighlightSearch(trimmedQuery, caseSensitive);
    } else {
      this.handleFilterSearch(trimmedQuery, caseSensitive, autoExpand);
    }
  }
  /**
   * 高亮搜索模式：高亮匹配的节点，显示所有内容
   */
  handleHighlightSearch(query, caseSensitive) {
    const allBlocks = getAllBlocks(this.editor.getState().blocks);
    const matchingBlocks = this.findMatchingBlocks(allBlocks, query, caseSensitive);
    this.blockElements.forEach((item) => {
      const element = item.getElement();
      element.classList.remove("workflowy-filtered-hidden");
      element.classList.remove("search-matched-node");
      element.classList.remove("search-parent-node");
      element.style.display = "";
    });
    this.blockElements.forEach((item, blockId) => {
      const contentEl = item.getElement().querySelector(".workflowy-content-wrapper, .workflowy-content");
      if (!contentEl)
        return;
      if (matchingBlocks.has(blockId)) {
        this.highlightTextInContent(contentEl, query, caseSensitive);
      } else {
        this.removeTextHighlight(contentEl);
      }
    });
  }
  /**
   * 过滤搜索模式：只显示匹配的节点及其父节点
   */
  handleFilterSearch(query, caseSensitive, autoExpand) {
    const allBlocks = getAllBlocks(this.editor.getState().blocks);
    const matchingBlocks = this.findMatchingBlocks(allBlocks, query, caseSensitive);
    const visibleBlocks = this.collectVisibleBlocks(allBlocks, matchingBlocks);
    if (autoExpand) {
      this.expandMatchedBlocks(matchingBlocks);
    }
    this.blockElements.forEach((item, blockId) => {
      const element = item.getElement();
      const contentEl = element.querySelector(".workflowy-content-wrapper, .workflowy-content");
      const collapseEl = element.querySelector(".workflowy-collapse");
      const collapsePlaceholder = element.querySelector(".workflowy-collapse-placeholder");
      const hasChildren = !!(collapseEl || collapsePlaceholder);
      if (visibleBlocks.has(blockId)) {
        element.classList.remove("workflowy-filtered-hidden");
        element.style.display = "";
        if (matchingBlocks.has(blockId)) {
          element.classList.add("search-matched-node");
          element.classList.remove("search-parent-node");
          if (contentEl) {
            this.highlightTextInContent(contentEl, query, caseSensitive);
          }
        } else {
          element.classList.remove("search-matched-node");
          element.classList.add("search-parent-node");
          if (contentEl) {
            this.removeTextHighlight(contentEl);
          }
        }
      } else {
        element.classList.add("workflowy-filtered-hidden");
        element.style.display = "none";
        element.classList.remove("search-matched-node");
        element.classList.remove("search-parent-node");
        if (contentEl) {
          this.removeTextHighlight(contentEl);
        }
      }
    });
  }
  /**
   * 查找匹配的节点
   */
  findMatchingBlocks(blocks, query, caseSensitive) {
    const matchingIds = /* @__PURE__ */ new Set();
    const searchQuery = caseSensitive ? query : query.toLowerCase();
    for (const block of blocks) {
      const content = caseSensitive ? block.content : block.content.toLowerCase();
      if (content.includes(searchQuery)) {
        matchingIds.add(block.id);
      }
    }
    return matchingIds;
  }
  /**
   * 收集所有应该可见的节点（匹配节点 + 所有祖先节点）
   */
  collectVisibleBlocks(allBlocks, matchingBlocks) {
    const visibleBlocks = /* @__PURE__ */ new Set();
    for (const blockId of matchingBlocks) {
      const block = allBlocks.find((b) => b.id === blockId);
      if (block) {
        visibleBlocks.add(blockId);
        this.addAncestors(block, allBlocks, visibleBlocks);
      }
    }
    return visibleBlocks;
  }
  /**
   * 递归添加所有祖先节点
   */
  addAncestors(block, allBlocks, visibleSet) {
    const parent = this.findParentBlock(block, allBlocks);
    if (parent) {
      visibleSet.add(parent.id);
      this.addAncestors(parent, allBlocks, visibleSet);
    }
  }
  /**
   * 查找节点的父节点
   */
  findParentBlock(block, allBlocks) {
    for (const potentialParent of allBlocks) {
      if (potentialParent.children.some((child) => child.id === block.id)) {
        return potentialParent;
      }
      const parentInChildren = this.findParentInChildren(block, potentialParent.children);
      if (parentInChildren) {
        return parentInChildren;
      }
    }
    return null;
  }
  /**
   * 在子节点中递归查找父节点
   */
  findParentInChildren(block, children) {
    for (const child of children) {
      if (child.children.some((c) => c.id === block.id)) {
        return child;
      }
      const found = this.findParentInChildren(block, child.children);
      if (found) {
        return found;
      }
    }
    return null;
  }
  /**
   * 展开包含匹配内容的折叠节点
   * 包括匹配节点本身和包含匹配节点的父节点
   */
  expandMatchedBlocks(matchingBlocks) {
    const state = this.editor.getState();
    const allBlocks = getAllBlocks(state.blocks);
    const blocksToExpand = /* @__PURE__ */ new Set();
    for (const blockId of matchingBlocks) {
      blocksToExpand.add(blockId);
    }
    for (const blockId of matchingBlocks) {
      const block = allBlocks.find((b) => b.id === blockId);
      if (block) {
        let parent = this.findParentBlock(block, allBlocks);
        while (parent) {
          blocksToExpand.add(parent.id);
          parent = this.findParentBlock(parent, allBlocks);
        }
      }
    }
    for (const blockId of blocksToExpand) {
      if (state.collapsedBlocks.has(blockId)) {
        this.editor.toggleCollapse(blockId);
      }
    }
    this.renderBlocks();
  }
  /**
   * 在内容元素中高亮匹配的文本
   * 支持源码模式和 Live Preview 模式
   */
  highlightTextInContent(contentEl, query, caseSensitive) {
    const displayEl = contentEl.querySelector(".workflowy-content-display");
    const targetEl = displayEl || contentEl;
    if (!targetEl)
      return;
    const textContent = targetEl.textContent || "";
    if (!textContent)
      return;
    const searchQuery = caseSensitive ? query : query.toLowerCase();
    const searchContent = caseSensitive ? textContent : textContent.toLowerCase();
    const matches = [];
    let index = 0;
    while ((index = searchContent.indexOf(searchQuery, index)) !== -1) {
      matches.push({ start: index, end: index + query.length });
      index += query.length;
    }
    if (matches.length > 0) {
      let html = "";
      let lastIndex = 0;
      for (const match of matches) {
        html += this.escapeHtml(textContent.substring(lastIndex, match.start));
        html += '<mark class="search-highlight">' + this.escapeHtml(textContent.substring(match.start, match.end)) + "</mark>";
        lastIndex = match.end;
      }
      html += this.escapeHtml(textContent.substring(lastIndex));
      const isEditable = targetEl.getAttribute("contenteditable");
      targetEl.innerHTML = html;
      if (isEditable) {
        targetEl.setAttribute("contenteditable", isEditable);
      }
    }
  }
  /**
   * 移除内容元素中的文本高亮
   * 支持源码模式和 Live Preview 模式
   */
  removeTextHighlight(contentEl) {
    const displayEl = contentEl.querySelector(".workflowy-content-display");
    const targetEl = displayEl || contentEl;
    if (!targetEl)
      return;
    const marks = targetEl.querySelectorAll("mark.search-highlight");
    if (marks.length > 0) {
      const textContent = targetEl.textContent || "";
      const isEditable = targetEl.getAttribute("contenteditable");
      targetEl.textContent = textContent;
      if (isEditable) {
        targetEl.setAttribute("contenteditable", isEditable);
      }
    }
  }
  /**
   * HTML 转义
   */
  escapeHtml(text) {
    const div = document.createElement("div");
    div.textContent = text;
    return div.innerHTML;
  }
  /**
   * 清除搜索状态
   */
  clearSearch() {
    this.blockElements.forEach((item) => {
      const element = item.getElement();
      const contentEl = element.querySelector(".workflowy-content-wrapper, .workflowy-content");
      element.classList.remove("search-match");
      element.classList.remove("search-matched-node");
      element.classList.remove("search-parent-node");
      element.classList.remove("workflowy-filtered-hidden");
      element.style.display = "";
      if (contentEl) {
        this.removeTextHighlight(contentEl);
      }
    });
    if (this.verticalLinesManager) {
      setTimeout(() => {
        if (this.verticalLinesManager) {
          this.verticalLinesManager.update();
        }
      }, 50);
    }
  }
  // 公共方法供插件调用
  async openFile(file) {
    await this.loadFile(file.path);
  }
  getCurrentFile() {
    return this.file;
  }
  /**
   * FileView 必需方法：返回当前文件
   */
  getFile() {
    return this.file;
  }
  /**
   * FileView 必需方法：加载文件
   */
  async onLoadFile(file) {
    this.file = file;
    const content = await this.app.vault.read(file);
    this.editor.loadFromMarkdown(content);
    await this.renderBlocks();
    this.updateNavigationHeader();
  }
  /**
   * FileView 必需方法：卸载文件
   */
  async onUnloadFile(file) {
    if (this.file) {
      await this.saveToFile();
    }
    this.file = null;
  }
  /**
   * 允许 Obsidian 识别此视图可以显示文件
   */
  canAcceptExtension(extension) {
    return extension === "md";
  }
  // 编辑器命令 - 供快捷键调用
  getFocusedBlockId() {
    return this.editor.getState().focusedBlockId;
  }
  executeIndent() {
    const focusedId = this.getFocusedBlockId();
    if (!focusedId)
      return false;
    if (this.editor.indentBlock(focusedId)) {
      this.renderBlocks();
      setTimeout(() => {
        const item = this.blockElements.get(focusedId);
        item == null ? void 0 : item.focus();
      }, 10);
      return true;
    }
    return false;
  }
  executeOutdent() {
    const focusedId = this.getFocusedBlockId();
    if (!focusedId)
      return false;
    if (this.editor.outdentBlock(focusedId)) {
      this.renderBlocks();
      setTimeout(() => {
        const item = this.blockElements.get(focusedId);
        item == null ? void 0 : item.focus();
      }, 10);
      return true;
    }
    return false;
  }
  executeMoveUp() {
    const focusedId = this.getFocusedBlockId();
    if (!focusedId)
      return false;
    if (this.editor.moveBlockUp(focusedId)) {
      this.renderBlocks();
      setTimeout(() => {
        const item = this.blockElements.get(focusedId);
        item == null ? void 0 : item.focus();
      }, 10);
      return true;
    }
    return false;
  }
  executeMoveDown() {
    const focusedId = this.getFocusedBlockId();
    if (!focusedId)
      return false;
    if (this.editor.moveBlockDown(focusedId)) {
      this.renderBlocks();
      setTimeout(() => {
        const item = this.blockElements.get(focusedId);
        item == null ? void 0 : item.focus();
      }, 10);
      return true;
    }
    return false;
  }
  executeToggleCollapse() {
    const focusedId = this.getFocusedBlockId();
    if (!focusedId)
      return false;
    if (this.editor.toggleCollapse(focusedId)) {
      this.renderBlocks();
      setTimeout(() => {
        const item = this.blockElements.get(focusedId);
        item == null ? void 0 : item.focus();
      }, 10);
      return true;
    }
    return false;
  }
  executeUndo() {
    var _a, _b;
    if (this.editor.undo()) {
      const state = this.editor.getState();
      if ((_a = this.zoomManager) == null ? void 0 : _a.isZoomed()) {
        const zoomedBlockId = this.zoomManager.getZoomedBlockId();
        if (zoomedBlockId) {
          const allBlocks = getAllBlocks(state.blocks);
          const zoomedBlock = allBlocks.find((b) => b.id === zoomedBlockId);
          if (!zoomedBlock) {
            console.warn("[WorkflowyView] Zoomed block no longer exists after undo, exiting zoom");
            this.zoomManager.zoomOut();
          }
        }
      }
      if (state.blocks.length === 0 && !((_b = this.zoomManager) == null ? void 0 : _b.isZoomed())) {
        this.editor.createNewBlock();
      }
      this.renderBlocks();
      return true;
    }
    return false;
  }
  executeRedo() {
    var _a, _b;
    if (this.editor.redo()) {
      const state = this.editor.getState();
      if ((_a = this.zoomManager) == null ? void 0 : _a.isZoomed()) {
        const zoomedBlockId = this.zoomManager.getZoomedBlockId();
        if (zoomedBlockId) {
          const allBlocks = getAllBlocks(state.blocks);
          const zoomedBlock = allBlocks.find((b) => b.id === zoomedBlockId);
          if (!zoomedBlock) {
            console.warn("[WorkflowyView] Zoomed block no longer exists after redo, exiting zoom");
            this.zoomManager.zoomOut();
          }
        }
      }
      if (state.blocks.length === 0 && !((_b = this.zoomManager) == null ? void 0 : _b.isZoomed())) {
        this.editor.createNewBlock();
      }
      this.renderBlocks();
      return true;
    }
    return false;
  }
  executeDeleteBlock() {
    const focusedId = this.getFocusedBlockId();
    if (!focusedId)
      return false;
    if (this.editor.deleteBlock(focusedId)) {
      this.renderBlocks();
      return true;
    }
    return false;
  }
  /**
   * 刷新视图（用于设置更改后重新渲染）
   */
  refresh() {
    this.saveAllEditingContent();
    this.renderBlocks();
  }
  /**
   * 保存所有正在编辑的内容（Live Preview 模式）
   */
  saveAllEditingContent() {
    const allTextareas = this.container.querySelectorAll(".workflowy-content-editor");
    let savedCount = 0;
    allTextareas.forEach((textarea) => {
      const blockId = textarea.getAttribute("data-block-id");
      const content = textarea.value;
      if (blockId && content) {
        const currentBlock = this.editor.getState().blocks.find((b) => b.id === blockId);
        if (currentBlock && currentBlock.content !== content) {
          this.editor.updateBlockContent(blockId, content);
          savedCount++;
        }
      }
    });
    if (this.file && savedCount > 0) {
      this.saveToFile();
    }
  }
};

// src/isolation/command-proxy.ts
var CommandProxy = class {
  constructor() {
    this.commandRegistry = /* @__PURE__ */ new Map();
    this.executionLogs = [];
    this.maxLogSize = 500;
    this.isolationLayer = IsolationLayer.getInstance();
    this.viewStateManager = ViewStateManager.getInstance();
  }
  /**
   * 获取单例实例
   */
  static getInstance() {
    if (!CommandProxy.instance) {
      CommandProxy.instance = new CommandProxy();
    }
    return CommandProxy.instance;
  }
  /**
   * 注册命令（带隔离控制）
   */
  registerCommand(command) {
    this.commandRegistry.set(command.id, command);
    const proxiedCommand = {
      id: command.id,
      name: command.name,
      hotkeys: command.hotkeys,
      mobileOnly: command.mobileOnly
    };
    if (command.checkCallback) {
      proxiedCommand.checkCallback = (checking) => {
        const canExecute = this.canExecuteCommand(command.id);
        if (checking) {
          return canExecute;
        }
        if (!canExecute) {
          this.logCommandExecution(command.id, false, true, "View type mismatch");
          return false;
        }
        try {
          const result = command.checkCallback(checking);
          this.logCommandExecution(command.id, true, false);
          return result;
        } catch (error) {
          console.error(`[CommandProxy] Error executing command ${command.id}:`, error);
          this.logCommandExecution(command.id, false, false, String(error));
          return false;
        }
      };
    } else if (command.callback) {
      proxiedCommand.checkCallback = (checking) => {
        const canExecute = this.canExecuteCommand(command.id);
        if (checking) {
          return canExecute;
        }
        if (!canExecute) {
          this.logCommandExecution(command.id, false, true, "View type mismatch");
          return false;
        }
        try {
          command.callback();
          this.logCommandExecution(command.id, true, false);
          return true;
        } catch (error) {
          console.error(`[CommandProxy] Error executing command ${command.id}:`, error);
          this.logCommandExecution(command.id, false, false, String(error));
          return false;
        }
      };
    } else if (command.editorCallback) {
      proxiedCommand.editorCheckCallback = (checking, editor, view) => {
        const canExecute = this.canExecuteCommand(command.id);
        if (checking) {
          return canExecute;
        }
        if (!canExecute) {
          this.logCommandExecution(command.id, false, true, "View type mismatch");
          return false;
        }
        try {
          command.editorCallback(editor, view);
          this.logCommandExecution(command.id, true, false);
          return true;
        } catch (error) {
          console.error(`[CommandProxy] Error executing command ${command.id}:`, error);
          this.logCommandExecution(command.id, false, false, String(error));
          return false;
        }
      };
    }
    return proxiedCommand;
  }
  /**
   * 检查命令是否可以执行
   */
  canExecuteCommand(commandId, leaf) {
    var _a;
    const command = this.commandRegistry.get(commandId);
    if (!command) {
      console.warn(`[CommandProxy] Unknown command: ${commandId}`);
      return false;
    }
    if (!leaf) {
      const activeViewType = this.viewStateManager.getActiveViewType((_a = window.app) == null ? void 0 : _a.workspace);
      return activeViewType === command.requiredViewType;
    }
    const currentViewType = this.viewStateManager.getViewType(leaf);
    return currentViewType === command.requiredViewType;
  }
  /**
   * 执行命令（带完整检查）
   */
  executeCommand(commandId, context) {
    const command = this.commandRegistry.get(commandId);
    if (!command) {
      console.error(`[CommandProxy] Cannot execute unknown command: ${commandId}`);
      return false;
    }
    const checkResult = this.isolationLayer.checkCommandExecution(
      commandId,
      command.requiredViewType,
      context.leaf
    );
    if (!checkResult.allowed) {
      this.logCommandExecution(commandId, false, true, checkResult.reason);
      console.warn(`[CommandProxy] Command ${commandId} blocked:`, checkResult.reason);
      return false;
    }
    try {
      if (command.callback) {
        command.callback();
      } else if (command.checkCallback) {
        command.checkCallback(false);
      }
      this.logCommandExecution(commandId, true, false);
      return true;
    } catch (error) {
      console.error(`[CommandProxy] Error executing command ${commandId}:`, error);
      this.logCommandExecution(commandId, false, false, String(error));
      return false;
    }
  }
  /**
   * 获取命令信息
   */
  getCommandInfo(commandId) {
    return this.commandRegistry.get(commandId);
  }
  /**
   * 获取所有注册的命令
   */
  getAllCommands() {
    return Array.from(this.commandRegistry.values());
  }
  /**
   * 获取特定视图类型的命令
   */
  getCommandsForViewType(viewType) {
    return Array.from(this.commandRegistry.values()).filter((cmd) => cmd.requiredViewType === viewType);
  }
  /**
   * 获取执行日志
   */
  getExecutionLogs() {
    return [...this.executionLogs];
  }
  /**
   * 获取被阻止的命令统计
   */
  getBlockedCommandStats() {
    const stats = {};
    for (const log of this.executionLogs) {
      if (log.blocked) {
        stats[log.commandId] = (stats[log.commandId] || 0) + 1;
      }
    }
    return stats;
  }
  /**
   * 清除执行日志
   */
  clearLogs() {
    this.executionLogs = [];
  }
  /**
   * 记录命令执行
   */
  logCommandExecution(commandId, success, blocked, reason) {
    var _a;
    const log = {
      commandId,
      timestamp: Date.now(),
      viewType: this.viewStateManager.getActiveViewType((_a = window.app) == null ? void 0 : _a.workspace),
      success,
      blocked,
      reason
    };
    this.executionLogs.push(log);
    if (this.executionLogs.length > this.maxLogSize) {
      this.executionLogs = this.executionLogs.slice(-this.maxLogSize);
    }
    if (blocked) {
      console.warn(`[CommandProxy] Command ${commandId} blocked: ${reason}`);
    }
  }
  /**
   * 调试：打印状态
   */
  debugPrintState() {
  }
};

// src/isolation/runtime-validator.ts
var RuntimeValidator = class {
  constructor() {
    this.validationResults = [];
    this.maxResultSize = 1e3;
    this.assertionsEnabled = true;
    this.viewStateManager = ViewStateManager.getInstance();
    this.isolationLayer = IsolationLayer.getInstance();
    this.commandProxy = CommandProxy.getInstance();
    this.eventDelegator = EventDelegator.getInstance();
  }
  /**
   * 获取单例实例
   */
  static getInstance() {
    if (!RuntimeValidator.instance) {
      RuntimeValidator.instance = new RuntimeValidator();
    }
    return RuntimeValidator.instance;
  }
  /**
   * 启用/禁用断言
   */
  setAssertionsEnabled(enabled) {
    this.assertionsEnabled = enabled;
  }
  /**
   * 断言：确保条件为真
   */
  assert(condition, message, level = "error" /* ERROR */, context) {
    if (!this.assertionsEnabled)
      return;
    if (!condition) {
      const result = {
        passed: false,
        level,
        message: `Assertion failed: ${message}`,
        timestamp: Date.now(),
        context
      };
      this.recordValidation(result);
      if (level === "critical" /* CRITICAL */ || level === "error" /* ERROR */) {
        console.error(`[RuntimeValidator] ${result.message}`, context);
        throw new Error(result.message);
      } else {
        console.warn(`[RuntimeValidator] ${result.message}`, context);
      }
    }
  }
  /**
   * 验证：视图状态一致性
   */
  validateViewStateConsistency() {
    try {
      const stats = this.viewStateManager.getStatistics();
      const hasWorkflowyViews = stats.workflowy > 0;
      const violations = this.isolationLayer.getViolations();
      if (hasWorkflowyViews && violations.length > 10) {
        const result2 = {
          passed: false,
          level: "warning" /* WARNING */,
          message: `Multiple isolation violations detected (${violations.length}) with active Workflowy views`,
          timestamp: Date.now(),
          context: { stats, violationCount: violations.length }
        };
        this.recordValidation(result2);
        return result2;
      }
      const result = {
        passed: true,
        level: "info" /* INFO */,
        message: "View state consistency check passed",
        timestamp: Date.now(),
        context: { stats }
      };
      return result;
    } catch (error) {
      const result = {
        passed: false,
        level: "error" /* ERROR */,
        message: `View state consistency check failed: ${error}`,
        timestamp: Date.now()
      };
      this.recordValidation(result);
      return result;
    }
  }
  /**
   * 验证：样式隔离
   */
  validateStyleIsolation() {
    try {
      const containers = document.querySelectorAll(".workflowy-container");
      if (containers.length === 0) {
        return {
          passed: true,
          level: "info" /* INFO */,
          message: "No Workflowy containers present",
          timestamp: Date.now()
        };
      }
      const styleSheets = Array.from(document.styleSheets);
      let unscopedRules = 0;
      for (const sheet of styleSheets) {
        try {
          const rules = Array.from(sheet.cssRules || []);
          for (const rule of rules) {
            if (rule instanceof CSSKeyframesRule) {
              continue;
            }
            if (rule instanceof CSSStyleRule) {
              const selector = rule.selectorText;
              if (this.isWorkflowySelector(selector) && !this.isProperlyScoped(selector)) {
                unscopedRules++;
              }
            }
          }
        } catch (e) {
          continue;
        }
      }
      if (unscopedRules > 5) {
        const result = {
          passed: false,
          level: "warning" /* WARNING */,
          message: `Found ${unscopedRules} unscoped Workflowy style rules`,
          timestamp: Date.now(),
          context: { unscopedRules }
        };
        this.recordValidation(result);
        return result;
      } else if (unscopedRules > 0) {
        return {
          passed: true,
          level: "info" /* INFO */,
          message: `Style isolation check passed with ${unscopedRules} minor warnings`,
          timestamp: Date.now(),
          context: { unscopedRules }
        };
      }
      return {
        passed: true,
        level: "info" /* INFO */,
        message: "Style isolation check passed",
        timestamp: Date.now()
      };
    } catch (error) {
      return {
        passed: true,
        level: "info" /* INFO */,
        message: `Style isolation check skipped: ${error}`,
        timestamp: Date.now()
      };
    }
  }
  /**
   * 验证：命令隔离
   */
  validateCommandIsolation() {
    try {
      const blockedStats = this.commandProxy.getBlockedCommandStats();
      const totalBlocked = Object.values(blockedStats).reduce((a, b) => a + b, 0);
      if (totalBlocked > 20) {
        const result = {
          passed: false,
          level: "warning" /* WARNING */,
          message: `High number of blocked commands (${totalBlocked})`,
          timestamp: Date.now(),
          context: { blockedStats }
        };
        this.recordValidation(result);
        return result;
      }
      return {
        passed: true,
        level: "info" /* INFO */,
        message: "Command isolation check passed",
        timestamp: Date.now(),
        context: { totalBlocked }
      };
    } catch (error) {
      const result = {
        passed: false,
        level: "error" /* ERROR */,
        message: `Command isolation check failed: ${error}`,
        timestamp: Date.now()
      };
      this.recordValidation(result);
      return result;
    }
  }
  /**
   * 验证：事件隔离
   */
  validateEventIsolation() {
    try {
      const blockedStats = this.eventDelegator.getBlockedEventStats();
      const totalBlocked = Object.values(blockedStats).reduce((a, b) => a + b, 0);
      if (totalBlocked > 50) {
        const result = {
          passed: false,
          level: "warning" /* WARNING */,
          message: `High number of blocked events (${totalBlocked})`,
          timestamp: Date.now(),
          context: { blockedStats }
        };
        this.recordValidation(result);
        return result;
      }
      return {
        passed: true,
        level: "info" /* INFO */,
        message: "Event isolation check passed",
        timestamp: Date.now(),
        context: { totalBlocked }
      };
    } catch (error) {
      const result = {
        passed: false,
        level: "error" /* ERROR */,
        message: `Event isolation check failed: ${error}`,
        timestamp: Date.now()
      };
      this.recordValidation(result);
      return result;
    }
  }
  /**
   * 执行完整的健康检查
   */
  performHealthCheck() {
    const checks = {
      viewStateManager: true,
      isolationLayer: true,
      commandProxy: true,
      eventDelegator: true
    };
    const issues = [];
    try {
      const viewStateResult = this.validateViewStateConsistency();
      if (!viewStateResult.passed) {
        checks.viewStateManager = false;
        issues.push(viewStateResult);
      }
    } catch (error) {
      checks.viewStateManager = false;
      issues.push({
        passed: false,
        level: "error" /* ERROR */,
        message: `ViewStateManager check failed: ${error}`,
        timestamp: Date.now()
      });
    }
    try {
      const styleResult = this.validateStyleIsolation();
      if (!styleResult.passed) {
        checks.isolationLayer = false;
        issues.push(styleResult);
      }
    } catch (error) {
      checks.isolationLayer = false;
      issues.push({
        passed: false,
        level: "error" /* ERROR */,
        message: `IsolationLayer check failed: ${error}`,
        timestamp: Date.now()
      });
    }
    try {
      const commandResult = this.validateCommandIsolation();
      if (!commandResult.passed) {
        checks.commandProxy = false;
        issues.push(commandResult);
      }
    } catch (error) {
      checks.commandProxy = false;
      issues.push({
        passed: false,
        level: "error" /* ERROR */,
        message: `CommandProxy check failed: ${error}`,
        timestamp: Date.now()
      });
    }
    try {
      const eventResult = this.validateEventIsolation();
      if (!eventResult.passed) {
        checks.eventDelegator = false;
        issues.push(eventResult);
      }
    } catch (error) {
      checks.eventDelegator = false;
      issues.push({
        passed: false,
        level: "error" /* ERROR */,
        message: `EventDelegator check failed: ${error}`,
        timestamp: Date.now()
      });
    }
    const healthy = Object.values(checks).every((check) => check);
    const result = {
      healthy,
      checks,
      issues,
      timestamp: Date.now()
    };
    return result;
  }
  /**
   * 获取所有验证结果
   */
  getValidationResults() {
    return [...this.validationResults];
  }
  /**
   * 获取错误和警告
   */
  getIssues() {
    return this.validationResults.filter(
      (r) => r.level === "error" /* ERROR */ || r.level === "warning" /* WARNING */ || r.level === "critical" /* CRITICAL */
    );
  }
  /**
   * 清除验证结果
   */
  clearResults() {
    this.validationResults = [];
  }
  /**
   * 记录验证结果
   */
  recordValidation(result) {
    this.validationResults.push(result);
    if (this.validationResults.length > this.maxResultSize) {
      this.validationResults = this.validationResults.slice(-this.maxResultSize);
    }
  }
  /**
   * 检查是否是 Workflowy 选择器
   */
  isWorkflowySelector(selector) {
    return selector.includes("workflowy") || selector.includes("block-") || selector.includes("collapse-") || selector.includes("outline-");
  }
  /**
   * 检查选择器是否正确限定作用域
   */
  isProperlyScoped(selector) {
    return selector.startsWith(".workflowy-container") || selector.includes(".workflowy-container ");
  }
  /**
   * 调试：打印状态
   */
  debugPrintState() {
  }
};

// src/isolation/index.ts
function initializeIsolationSystem(options) {
  const viewStateManager = ViewStateManager.getInstance();
  const isolationLayer = IsolationLayer.getInstance();
  const commandProxy = CommandProxy.getInstance();
  const eventDelegator = EventDelegator.getInstance();
  const runtimeValidator = RuntimeValidator.getInstance();
  if ((options == null ? void 0 : options.strictMode) !== void 0) {
    isolationLayer.setStrictMode(options.strictMode);
  }
  if ((options == null ? void 0 : options.enableAssertions) !== void 0) {
    runtimeValidator.setAssertionsEnabled(options.enableAssertions);
  }
  if (options == null ? void 0 : options.debugMode) {
    viewStateManager.debugPrintState();
    isolationLayer.debugPrintState();
    commandProxy.debugPrintState();
    eventDelegator.debugPrintState();
    runtimeValidator.debugPrintState();
  }
  return {
    viewStateManager,
    isolationLayer,
    commandProxy,
    eventDelegator,
    runtimeValidator
  };
}
function cleanupIsolationSystem() {
  const eventDelegatorInstance = EventDelegator.getInstance();
  eventDelegatorInstance.cleanup();
  ViewStateManager.reset();
}
function performIsolationHealthCheck() {
  const runtimeValidatorInstance = RuntimeValidator.getInstance();
  return runtimeValidatorInstance.performHealthCheck();
}

// src/settings.ts
var DEFAULT_SETTINGS = {
  ui: {
    indentSize: 30,
    showBullets: true,
    showCollapseIndicators: true,
    animationsEnabled: false,
    theme: "default"
    // 默认主题
  },
  editor: {
    autoSave: true,
    autoSaveDelay: 1e3,
    placeholder: "\u8F93\u5165\u5185\u5BB9...",
    renderMode: "source"
    // 默认源码模式（向后兼容）
  },
  search: {
    mode: "highlight",
    // 默认使用高亮模式
    caseSensitive: false,
    // 默认不区分大小写
    autoExpandMatches: true
    // 默认自动展开匹配节点
  },
  dragDrop: {
    enabled: true,
    showDropIndicators: true,
    allowNestedDrop: true
  },
  isolation: {
    strictMode: true,
    enableAssertions: true,
    debugMode: false,
    healthCheckInterval: 3e4
  }
};

// src/settings-tab.ts
var import_obsidian5 = require("obsidian");
var WorkflowySettingTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Workflowy\u63D2\u4EF6\u8BBE\u7F6E" });
    containerEl.createEl("h2", { text: "\u5FEB\u6377\u952E\u8BBE\u7F6E" });
    const hotkeyInfo = containerEl.createEl("div", {
      cls: "setting-item-description"
    });
    hotkeyInfo.createEl("p", {
      text: '\u5FEB\u6377\u952E\u53EF\u4EE5\u5728 Obsidian \u7684"\u8BBE\u7F6E > \u5FEB\u6377\u952E"\u4E2D\u914D\u7F6E\u3002'
    });
    hotkeyInfo.createEl("p", {
      text: '\u641C\u7D22"Workflowy"\u5373\u53EF\u627E\u5230\u6240\u6709\u53EF\u7528\u7684\u5FEB\u6377\u952E\u547D\u4EE4\u3002'
    });
    const openHotkeysButton = new import_obsidian5.Setting(containerEl).setName("\u6253\u5F00\u5FEB\u6377\u952E\u8BBE\u7F6E").setDesc("\u8DF3\u8F6C\u5230Obsidian\u7684\u5FEB\u6377\u952E\u8BBE\u7F6E\u9875\u9762").addButton((button) => button.setButtonText("\u6253\u5F00\u5FEB\u6377\u952E\u8BBE\u7F6E").setCta().onClick(() => {
      this.app.setting.open();
      this.app.setting.openTabById("hotkeys");
    }));
    containerEl.createEl("h2", { text: "UI\u8BBE\u7F6E" });
    new import_obsidian5.Setting(containerEl).setName("\u7F29\u8FDB\u5927\u5C0F").setDesc("\u6BCF\u7EA7\u7F29\u8FDB\u7684\u50CF\u7D20\u5927\u5C0F\uFF08\u9ED8\u8BA4\uFF1A30px\uFF09").addSlider((slider) => slider.setLimits(10, 60, 5).setValue(this.plugin.settings.ui.indentSize).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.ui.indentSize = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("\u663E\u793A\u5706\u70B9\u6807\u8BB0").setDesc("\u5728\u6BCF\u4E2A\u5757\u524D\u663E\u793A\u5706\u70B9\u6807\u8BB0").addToggle((toggle) => toggle.setValue(this.plugin.settings.ui.showBullets).onChange(async (value) => {
      this.plugin.settings.ui.showBullets = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("\u663E\u793A\u6298\u53E0\u6307\u793A\u5668").setDesc("\u5728\u6709\u5B50\u5757\u7684\u5757\u524D\u663E\u793A\u6298\u53E0/\u5C55\u5F00\u6307\u793A\u5668").addToggle((toggle) => toggle.setValue(this.plugin.settings.ui.showCollapseIndicators).onChange(async (value) => {
      this.plugin.settings.ui.showCollapseIndicators = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("\u542F\u7528\u52A8\u753B").setDesc("\u542F\u7528\u754C\u9762\u52A8\u753B\u6548\u679C\uFF08\u53EF\u80FD\u5F71\u54CD\u6027\u80FD\uFF09").addToggle((toggle) => toggle.setValue(this.plugin.settings.ui.animationsEnabled).onChange(async (value) => {
      this.plugin.settings.ui.animationsEnabled = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: "\u7F16\u8F91\u5668\u8BBE\u7F6E" });
    new import_obsidian5.Setting(containerEl).setName("\u81EA\u52A8\u4FDD\u5B58").setDesc("\u7F16\u8F91\u65F6\u81EA\u52A8\u4FDD\u5B58\u66F4\u6539").addToggle((toggle) => toggle.setValue(this.plugin.settings.editor.autoSave).onChange(async (value) => {
      this.plugin.settings.editor.autoSave = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("\u81EA\u52A8\u4FDD\u5B58\u5EF6\u8FDF").setDesc("\u81EA\u52A8\u4FDD\u5B58\u7684\u5EF6\u8FDF\u65F6\u95F4\uFF08\u6BEB\u79D2\uFF09").addSlider((slider) => slider.setLimits(500, 5e3, 500).setValue(this.plugin.settings.editor.autoSaveDelay).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.editor.autoSaveDelay = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("\u5360\u4F4D\u7B26\u6587\u672C").setDesc("\u7A7A\u5757\u663E\u793A\u7684\u5360\u4F4D\u7B26\u6587\u672C").addText((text) => text.setPlaceholder("\u8F93\u5165\u5185\u5BB9...").setValue(this.plugin.settings.editor.placeholder).onChange(async (value) => {
      this.plugin.settings.editor.placeholder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("\u6E32\u67D3\u6A21\u5F0F").setDesc("\u9009\u62E9\u5757\u5185\u5BB9\u7684\u663E\u793A\u65B9\u5F0F").addDropdown((dropdown) => dropdown.addOption("source", "\u6E90\u7801\u6A21\u5F0F - \u663E\u793A\u539F\u59CB Markdown \u8BED\u6CD5\uFF08\u5F53\u524D\u9ED8\u8BA4\uFF09").addOption("live-preview", "Live Preview - \u7F16\u8F91\u65F6\u663E\u793A\u6E90\u7801\uFF0C\u975E\u7F16\u8F91\u65F6\u663E\u793A\u6E32\u67D3\u6548\u679C").setValue(this.plugin.settings.editor.renderMode).onChange(async (value) => {
      this.plugin.settings.editor.renderMode = value;
      await this.plugin.saveSettings();
      this.plugin.refreshAllViews();
    }));
    containerEl.createEl("h2", { text: "\u641C\u7D22\u8BBE\u7F6E" });
    new import_obsidian5.Setting(containerEl).setName("\u641C\u7D22\u6A21\u5F0F").setDesc("\u9009\u62E9\u641C\u7D22\u65F6\u7684\u663E\u793A\u65B9\u5F0F").addDropdown((dropdown) => dropdown.addOption("highlight", "\u663E\u793A\u9AD8\u4EAE - \u9AD8\u4EAE\u5339\u914D\u7684\u8282\u70B9\uFF0C\u663E\u793A\u6240\u6709\u5185\u5BB9").addOption("filter", "\u8FC7\u6EE4\u8282\u70B9 - \u53EA\u663E\u793A\u5339\u914D\u7684\u8282\u70B9\u53CA\u5176\u7236\u8282\u70B9").setValue(this.plugin.settings.search.mode).onChange(async (value) => {
      this.plugin.settings.search.mode = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("\u533A\u5206\u5927\u5C0F\u5199").setDesc("\u641C\u7D22\u65F6\u662F\u5426\u533A\u5206\u5927\u5C0F\u5199").addToggle((toggle) => toggle.setValue(this.plugin.settings.search.caseSensitive).onChange(async (value) => {
      this.plugin.settings.search.caseSensitive = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("\u81EA\u52A8\u5C55\u5F00\u5339\u914D\u8282\u70B9").setDesc("\u641C\u7D22\u65F6\u81EA\u52A8\u5C55\u5F00\u5305\u542B\u5339\u914D\u5185\u5BB9\u7684\u6298\u53E0\u8282\u70B9").addToggle((toggle) => toggle.setValue(this.plugin.settings.search.autoExpandMatches).onChange(async (value) => {
      this.plugin.settings.search.autoExpandMatches = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: "\u62D6\u62FD\u8BBE\u7F6E" });
    new import_obsidian5.Setting(containerEl).setName("\u542F\u7528\u62D6\u62FD").setDesc("\u5141\u8BB8\u901A\u8FC7\u62D6\u62FD\u91CD\u65B0\u6392\u5217\u5757").addToggle((toggle) => toggle.setValue(this.plugin.settings.dragDrop.enabled).onChange(async (value) => {
      this.plugin.settings.dragDrop.enabled = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("\u663E\u793A\u653E\u7F6E\u6307\u793A\u5668").setDesc("\u62D6\u62FD\u65F6\u663E\u793A\u653E\u7F6E\u4F4D\u7F6E\u7684\u89C6\u89C9\u6307\u793A\u5668").addToggle((toggle) => toggle.setValue(this.plugin.settings.dragDrop.showDropIndicators).onChange(async (value) => {
      this.plugin.settings.dragDrop.showDropIndicators = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("\u5141\u8BB8\u5D4C\u5957\u653E\u7F6E").setDesc("\u5141\u8BB8\u5C06\u5757\u653E\u7F6E\u4E3A\u5176\u4ED6\u5757\u7684\u5B50\u5757").addToggle((toggle) => toggle.setValue(this.plugin.settings.dragDrop.allowNestedDrop).onChange(async (value) => {
      this.plugin.settings.dragDrop.allowNestedDrop = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: "\u9AD8\u7EA7\u8BBE\u7F6E" });
    new import_obsidian5.Setting(containerEl).setName("\u4E25\u683C\u6A21\u5F0F").setDesc("\u542F\u7528\u4E25\u683C\u7684\u529F\u80FD\u9694\u79BB\uFF08\u63A8\u8350\uFF09").addToggle((toggle) => toggle.setValue(this.plugin.settings.isolation.strictMode).onChange(async (value) => {
      this.plugin.settings.isolation.strictMode = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("\u542F\u7528\u65AD\u8A00").setDesc("\u542F\u7528\u8FD0\u884C\u65F6\u65AD\u8A00\u68C0\u67E5\uFF08\u7528\u4E8E\u8C03\u8BD5\uFF09").addToggle((toggle) => toggle.setValue(this.plugin.settings.isolation.enableAssertions).onChange(async (value) => {
      this.plugin.settings.isolation.enableAssertions = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("\u8C03\u8BD5\u6A21\u5F0F").setDesc("\u542F\u7528\u8C03\u8BD5\u65E5\u5FD7\uFF08\u53EF\u80FD\u4EA7\u751F\u5927\u91CF\u65E5\u5FD7\uFF09").addToggle((toggle) => toggle.setValue(this.plugin.settings.isolation.debugMode).onChange(async (value) => {
      this.plugin.settings.isolation.debugMode = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("\u5065\u5EB7\u68C0\u67E5\u95F4\u9694").setDesc("\u7CFB\u7EDF\u5065\u5EB7\u68C0\u67E5\u7684\u95F4\u9694\u65F6\u95F4\uFF08\u6BEB\u79D2\uFF09").addSlider((slider) => slider.setLimits(1e4, 12e4, 1e4).setValue(this.plugin.settings.isolation.healthCheckInterval).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.isolation.healthCheckInterval = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("\u91CD\u7F6E\u6240\u6709\u8BBE\u7F6E").setDesc("\u5C06\u6240\u6709\u8BBE\u7F6E\u6062\u590D\u4E3A\u9ED8\u8BA4\u503C").addButton((button) => button.setButtonText("\u91CD\u7F6E").setWarning().onClick(async () => {
      if (confirm("\u786E\u5B9A\u8981\u91CD\u7F6E\u6240\u6709\u8BBE\u7F6E\u5417\uFF1F\u6B64\u64CD\u4F5C\u4E0D\u53EF\u64A4\u9500\u3002")) {
        await this.plugin.resetSettings();
        this.display();
      }
    }));
  }
};

// src/main.ts
var WorkflowyPlugin = class extends import_obsidian6.Plugin {
  constructor() {
    super(...arguments);
    // 平台信息
    this.isMobile = false;
    this.isDesktop = false;
  }
  async onload() {
    this.detectPlatform();
    await this.loadSettings();
    this.initializeIsolation();
    this.registerView(
      WORKFLOWY_VIEW_TYPE,
      (leaf) => new WorkflowyView(leaf, this)
    );
    this.registerCommands();
    this.registerEventListeners();
    this.addSettingTab(new WorkflowySettingTab(this.app, this));
    this.scheduleHealthChecks();
  }
  onunload() {
    const healthCheck = performIsolationHealthCheck();
    if (!healthCheck.healthy) {
      console.warn("[WorkflowyPlugin] Final health check failed:", healthCheck);
    }
    cleanupIsolationSystem();
  }
  /**
   * 检测平台
   */
  detectPlatform() {
    this.isMobile = import_obsidian6.Platform.isMobile;
    this.isDesktop = import_obsidian6.Platform.isDesktop;
  }
  /**
   * 初始化隔离系统
   */
  initializeIsolation() {
    const isolationSystem = initializeIsolationSystem({
      strictMode: this.settings.isolation.strictMode,
      enableAssertions: this.settings.isolation.enableAssertions,
      debugMode: this.settings.isolation.debugMode
    });
    this.viewStateManager = isolationSystem.viewStateManager;
    this.isolationLayer = isolationSystem.isolationLayer;
    this.commandProxy = isolationSystem.commandProxy;
    this.eventDelegator = isolationSystem.eventDelegator;
    this.runtimeValidator = isolationSystem.runtimeValidator;
  }
  /**
   * 注册命令（通过命令代理）
   */
  registerCommands() {
    this.addCommand({
      id: "toggle-view-mode",
      name: "\u5207\u6362\u5927\u7EB2/Markdown\u89C6\u56FE",
      hotkeys: this.isMobile ? [] : [{ modifiers: ["Mod", "Shift"], key: "o" }],
      checkCallback: (checking) => {
        const activeLeaf = this.app.workspace.activeLeaf;
        const activeFile = this.app.workspace.getActiveFile();
        const workflowyView = this.app.workspace.getActiveViewOfType(WorkflowyView);
        const isInWorkflowy = workflowyView && this.viewStateManager.isInWorkflowyView(activeLeaf);
        const isInMarkdown = activeFile && activeFile.extension === "md" && this.viewStateManager.isInMarkdownView(activeLeaf);
        const canExecute = isInWorkflowy || isInMarkdown;
        if (checking) {
          return canExecute || false;
        }
        if (canExecute) {
          if (isInWorkflowy && workflowyView) {
            const file = workflowyView.getCurrentFile();
            if (file) {
              this.openAsMarkdown(file);
            }
          } else if (isInMarkdown && activeFile) {
            this.openAsWorkflowy(activeFile);
          }
        }
        return true;
      }
    });
    const openAsWorkflowyCmd = this.commandProxy.registerCommand({
      id: "open-as-workflowy",
      name: "\u6253\u5F00\u4E3A\u5927\u7EB2\u7B14\u8BB0",
      requiredViewType: "markdown" /* MARKDOWN */,
      checkCallback: (checking) => {
        const activeFile = this.app.workspace.getActiveFile();
        const activeLeaf = this.app.workspace.activeLeaf;
        const canExecute = activeFile && activeFile.extension === "md" && this.viewStateManager.isInMarkdownView(activeLeaf);
        if (checking) {
          return canExecute || false;
        }
        if (canExecute) {
          this.openAsWorkflowy(activeFile);
        }
        return true;
      }
    });
    this.addCommand(openAsWorkflowyCmd);
    const openAsMarkdownCmd = this.commandProxy.registerCommand({
      id: "open-as-markdown",
      name: "\u6253\u5F00\u4E3AMarkdown",
      requiredViewType: "workflowy-view" /* WORKFLOWY */,
      checkCallback: (checking) => {
        const activeView = this.app.workspace.getActiveViewOfType(WorkflowyView);
        const activeLeaf = this.app.workspace.activeLeaf;
        const canExecute = activeView && activeView.getCurrentFile() && this.viewStateManager.isInWorkflowyView(activeLeaf);
        if (checking) {
          return canExecute || false;
        }
        if (canExecute && activeView) {
          const file = activeView.getCurrentFile();
          if (file) {
            this.openAsMarkdown(file);
          }
        }
        return true;
      }
    });
    this.addCommand(openAsMarkdownCmd);
    this.registerEditorCommands();
  }
  /**
   * 注册编辑器命令
   */
  registerEditorCommands() {
    const desktopHotkeys = !this.isMobile;
    this.addCommand({
      id: "workflowy-indent",
      name: "Workflowy: \u589E\u52A0\u7F29\u8FDB",
      hotkeys: desktopHotkeys ? [{ modifiers: ["Mod"], key: "]" }] : [],
      checkCallback: (checking) => {
        const view = this.app.workspace.getActiveViewOfType(WorkflowyView);
        if (!view)
          return false;
        if (!checking) {
          view.executeIndent();
        }
        return true;
      }
    });
    this.addCommand({
      id: "workflowy-outdent",
      name: "Workflowy: \u51CF\u5C11\u7F29\u8FDB",
      hotkeys: desktopHotkeys ? [{ modifiers: ["Mod"], key: "[" }] : [],
      checkCallback: (checking) => {
        const view = this.app.workspace.getActiveViewOfType(WorkflowyView);
        if (!view)
          return false;
        if (!checking) {
          view.executeOutdent();
        }
        return true;
      }
    });
    this.addCommand({
      id: "workflowy-move-up",
      name: "Workflowy: \u5411\u4E0A\u79FB\u52A8\u5757",
      hotkeys: desktopHotkeys ? [{ modifiers: ["Mod", "Shift"], key: "ArrowUp" }] : [],
      checkCallback: (checking) => {
        const view = this.app.workspace.getActiveViewOfType(WorkflowyView);
        if (!view)
          return false;
        if (!checking) {
          view.executeMoveUp();
        }
        return true;
      }
    });
    this.addCommand({
      id: "workflowy-move-down",
      name: "Workflowy: \u5411\u4E0B\u79FB\u52A8\u5757",
      hotkeys: desktopHotkeys ? [{ modifiers: ["Mod", "Shift"], key: "ArrowDown" }] : [],
      checkCallback: (checking) => {
        const view = this.app.workspace.getActiveViewOfType(WorkflowyView);
        if (!view)
          return false;
        if (!checking) {
          view.executeMoveDown();
        }
        return true;
      }
    });
    this.addCommand({
      id: "workflowy-toggle-collapse",
      name: "Workflowy: \u6298\u53E0/\u5C55\u5F00\u5757",
      hotkeys: desktopHotkeys ? [{ modifiers: ["Mod"], key: "Enter" }] : [],
      checkCallback: (checking) => {
        const view = this.app.workspace.getActiveViewOfType(WorkflowyView);
        if (!view)
          return false;
        if (!checking) {
          view.executeToggleCollapse();
        }
        return true;
      }
    });
    this.addCommand({
      id: "workflowy-undo",
      name: "Workflowy: \u64A4\u9500",
      hotkeys: desktopHotkeys ? [{ modifiers: ["Mod"], key: "z" }] : [],
      checkCallback: (checking) => {
        const view = this.app.workspace.getActiveViewOfType(WorkflowyView);
        if (!view)
          return false;
        if (!checking) {
          view.executeUndo();
        }
        return true;
      }
    });
    this.addCommand({
      id: "workflowy-redo",
      name: "Workflowy: \u91CD\u505A",
      hotkeys: desktopHotkeys ? [
        { modifiers: ["Mod", "Shift"], key: "z" },
        { modifiers: ["Mod"], key: "y" }
      ] : [],
      checkCallback: (checking) => {
        const view = this.app.workspace.getActiveViewOfType(WorkflowyView);
        if (!view)
          return false;
        if (!checking) {
          view.executeRedo();
        }
        return true;
      }
    });
    this.addCommand({
      id: "workflowy-delete-block",
      name: "Workflowy: \u5220\u9664\u5F53\u524D\u5757",
      hotkeys: desktopHotkeys ? [{ modifiers: ["Mod", "Shift"], key: "Backspace" }] : [],
      checkCallback: (checking) => {
        const view = this.app.workspace.getActiveViewOfType(WorkflowyView);
        if (!view)
          return false;
        if (!checking) {
          view.executeDeleteBlock();
        }
        return true;
      }
    });
    this.addCommand({
      id: "workflowy-collapse-all",
      name: "Workflowy: \u6298\u53E0\u6240\u6709\u5757",
      checkCallback: (checking) => {
        const view = this.app.workspace.getActiveViewOfType(WorkflowyView);
        if (!view)
          return false;
        if (!checking) {
          view.collapseAll();
        }
        return true;
      }
    });
    this.addCommand({
      id: "workflowy-expand-all",
      name: "Workflowy: \u5C55\u5F00\u6240\u6709\u5757",
      checkCallback: (checking) => {
        const view = this.app.workspace.getActiveViewOfType(WorkflowyView);
        if (!view)
          return false;
        if (!checking) {
          view.expandAll();
        }
        return true;
      }
    });
  }
  /**
   * 注册事件监听器
   */
  registerEventListeners() {
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        this.addFileMenuItems(menu, file);
      })
    );
    this.registerEvent(
      this.app.workspace.on("editor-menu", (menu, editor, view) => {
        this.addEditorMenuItems(menu, view);
      })
    );
  }
  /**
   * 添加文件菜单项（带隔离检查）
   */
  addFileMenuItems(menu, file) {
    if (!(file instanceof import_obsidian6.TFile))
      return;
    if (file.extension !== "md")
      return;
    const activeLeaf = this.app.workspace.activeLeaf;
    if (!activeLeaf)
      return;
    if (this.isolationLayer.shouldShowMenuItem(activeLeaf, "workflowy")) {
      menu.addItem((item) => {
        item.setTitle("\u6253\u5F00\u4E3A\u5927\u7EB2\u7B14\u8BB0").setIcon("list-tree").onClick(() => {
          this.openAsWorkflowy(file);
        });
      });
    }
    if (this.isolationLayer.shouldShowMenuItem(activeLeaf, "markdown")) {
      menu.addItem((item) => {
        item.setTitle("\u6253\u5F00\u4E3AMarkdown").setIcon("edit").onClick(() => {
          this.openAsMarkdown(file);
        });
      });
    }
  }
  /**
   * 添加编辑器菜单项（带隔离检查）
   */
  addEditorMenuItems(menu, view) {
    if (view instanceof WorkflowyView) {
      const file = view.getCurrentFile();
      if (file) {
        menu.addItem((item) => {
          item.setTitle("\u6253\u5F00\u4E3AMarkdown").setIcon("edit").onClick(() => {
            this.openAsMarkdown(file);
          });
        });
      }
    }
  }
  /**
   * 打开文件为 Workflowy 视图（带验证）
   */
  async openAsWorkflowy(file) {
    const leaf = this.app.workspace.activeLeaf;
    if (!leaf) {
      console.error("[WorkflowyPlugin] No active leaf found");
      return;
    }
    if (!this.viewStateManager.isInMarkdownView(leaf)) {
      console.warn("[WorkflowyPlugin] Can only open as Workflowy from Markdown view");
      return;
    }
    await leaf.setViewState({
      type: WORKFLOWY_VIEW_TYPE,
      state: { file: file.path }
    });
    this.viewStateManager.updateViewState(leaf, {
      filePath: file.path,
      isActive: true
    });
  }
  /**
   * 打开文件为 Markdown 视图（带验证）
   */
  async openAsMarkdown(file) {
    const leaf = this.app.workspace.activeLeaf;
    if (!leaf) {
      console.error("[WorkflowyPlugin] No active leaf found");
      return;
    }
    if (!this.viewStateManager.isInWorkflowyView(leaf)) {
      console.warn("[WorkflowyPlugin] Can only open as Markdown from Workflowy view");
      return;
    }
    await leaf.setViewState({
      type: "markdown",
      state: {
        file: file.path,
        mode: "source"
      }
    });
    this.viewStateManager.updateViewState(leaf, {
      filePath: file.path,
      isActive: true
    });
  }
  /**
   * 定期健康检查
   */
  scheduleHealthChecks() {
    this.performHealthCheck();
    this.registerInterval(
      window.setInterval(() => {
        this.performHealthCheck();
      }, this.settings.isolation.healthCheckInterval)
    );
  }
  /**
   * 执行健康检查
   */
  performHealthCheck() {
    const healthCheck = performIsolationHealthCheck();
    if (!healthCheck.healthy) {
      console.warn("[WorkflowyPlugin] Health check failed:", healthCheck.issues);
    }
  }
  /**
   * 加载设置
   */
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  /**
   * 保存设置
   */
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * 重置设置
   */
  async resetSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS);
    await this.saveSettings();
  }
  /**
   * 刷新所有 Workflowy 视图
   */
  refreshAllViews() {
    this.app.workspace.getLeavesOfType(WORKFLOWY_VIEW_TYPE).forEach((leaf) => {
      const view = leaf.view;
      if (view instanceof WorkflowyView) {
        view.refresh();
      }
    });
  }
};
